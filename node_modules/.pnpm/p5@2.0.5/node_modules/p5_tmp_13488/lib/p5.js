/*! p5.js v2.0.5 September 1, 2025 */
var p5 = (function () {
  'use strict';

  /**
   * @module Constants
   * @submodule Constants
   * @for p5
   */

  const _PI = Math.PI;

  /**
   * Version of this p5.js.
   * @property {String} VERSION
   * @final
   */
  const VERSION = '2.0.5';

  // GRAPHICS RENDERER
  /**
   * The default, two-dimensional renderer in p5.js.
   *
   * Use this when calling <a href="#/p5/createCanvas"> (for example,
   * `createCanvas(400, 400, P2D)`) to specify a 2D context.
   *
   * @typedef {'p2d'} P2D
   * @property {P2D} P2D
   * @final
   */
  const P2D = 'p2d';

  /**
   * A high-dynamic-range (HDR) variant of the default, two-dimensional renderer.
   *
   * When available, this mode can allow for extended color ranges and more
   * dynamic color representation. Use it similarly to `P2D`:
   * `createCanvas(400, 400, P2DHDR)`.
   *
   * @typedef {'p2d-hdr'} P2DHDR
   * @property {P2DHDR} P2DHDR
   * @final
   */

  const P2DHDR = 'p2d-hdr';

  /**
   * One of the two render modes in p5.js, used for computationally intensive tasks like 3D rendering and shaders.
   *
   * `WEBGL` differs from the default <a href="/reference/p5/P2D">`P2D`</a> renderer in the following ways:
   *
   * - **Coordinate System** - When drawing in `WEBGL` mode, the origin point (0,0,0) is located at the center of the screen, not the top-left corner. See <a href="https://p5js.org/tutorials/coordinates-and-transformations/">the tutorial page about coordinates and transformations</a>.
   * - **3D Shapes** - `WEBGL` mode can be used to draw 3-dimensional shapes like <a href="#/p5/box">box()</a>, <a href="#/p5/sphere">sphere()</a>, <a href="#/p5/cone">cone()</a>, and <a href="https://p5js.org/reference/#3D%20Primitives">more</a>. See <a href="https://p5js.org/tutorials/custom-geometry/">the tutorial page about custom geometry</a> to make more complex objects.
   * - **Shape Detail** - When drawing in `WEBGL` mode, you can specify how smooth curves should be drawn by using a `detail` parameter. See <a href="https://github.com/processing/p5.js/wiki/Getting-started-with-WebGL-in-p5#3d-primitives-shapes">the wiki section about shapes</a> for a more information and an example.
   * - **Textures** - A texture is like a skin that wraps onto a shape. See <a href="https://github.com/processing/p5.js/wiki/Getting-started-with-WebGL-in-p5#textures">the wiki section about textures</a> for examples of mapping images onto surfaces with textures.
   * - **Materials and Lighting** - `WEBGL` offers different types of lights like <a href="#/p5/ambientLight">ambientLight()</a> to place around a scene. Materials like <a href="#/p5/specularMaterial">specularMaterial()</a> reflect the lighting to convey shape and depth. See <a href="https://p5js.org/tutorials/lights-camera-materials/">the tutorial page for styling and appearance</a> to experiment with different combinations.
   * - **Camera** - The viewport of a `WEBGL` sketch can be adjusted by changing camera attributes. See <a href="https://p5js.org/tutorials/lights-camera-materials#camera-and-view">the tutorial page section about cameras</a> for an explanation of camera controls.
   * - **Text** - `WEBGL` requires opentype/truetype font files to be preloaded using <a href="#/p5/loadFont">loadFont()</a>. See <a href="https://github.com/processing/p5.js/wiki/Getting-started-with-WebGL-in-p5#text">the wiki section about text</a> for details, along with a workaround.
   * - **Shaders** - Shaders are hardware accelerated programs that can be used for a variety of effects and graphics. See the <a href="https://p5js.org/tutorials/intro-to-shaders/">introduction to shaders</a> to get started with shaders in p5.js.
   * - **Graphics Acceleration** - `WEBGL` mode uses the graphics card instead of the CPU, so it may help boost the performance of your sketch (example: drawing more shapes on the screen at once).
   *
   * To learn more about WEBGL mode, check out <a href="https://p5js.org/tutorials/#webgl">all the interactive WEBGL tutorials</a> in the "Tutorials" section of this website, or read the wiki article <a href="https://github.com/processing/p5.js/wiki/Getting-started-with-WebGL-in-p5">"Getting started with WebGL in p5"</a>.
   *
   * @typedef {unique symbol} WEBGL
   * @property {WEBGL} WEBGL
   * @final
   */
  const WEBGL = 'webgl';
  /**
   * One of the two possible values of a WebGL canvas (either WEBGL or WEBGL2),
   * which can be used to determine what capabilities the rendering environment
   * has.
   * @typedef {unique symbol} WEBGL2
   * @property {WEBGL2} WEBGL2
   * @final
   */
  const WEBGL2 = 'webgl2';

  // ENVIRONMENT
  /**
   * @typedef {'default'} ARROW
   * @property {ARROW} ARROW
   * @final
   */
  const ARROW = 'default';

  /**
   * @property {String} SIMPLE
   * @final
   */
  const SIMPLE = 'simple';
  /**
   * @property {String} FULL
   * @final
   */
  const FULL = 'full';

  /**
   * @typedef {'crosshair'} CROSS
   * @property {CROSS} CROSS
   * @final
   */
  const CROSS = 'crosshair';
  /**
   * @typedef {'pointer'} HAND
   * @property {HAND} HAND
   * @final
   */
  const HAND = 'pointer';
  /**
   * @typedef {'move'} MOVE
   * @property {MOVE} MOVE
   * @final
   */
  const MOVE = 'move';
  /**
   * @typedef {'text'} TEXT
   * @property {TEXT} TEXT
   * @final
   */
  const TEXT = 'text';
  /**
   * @typedef {'wait'} WAIT
   * @property {WAIT} WAIT
   * @final
   */
  const WAIT = 'wait';

  // TRIGONOMETRY

  /**
   * A `Number` constant that's approximately 1.5708.
   *
   * `HALF_PI` is half the value of the mathematical constant π. It's useful for
   * many tasks that involve rotation and oscillation. For example, calling
   * `rotate(HALF_PI)` rotates the coordinate system `HALF_PI` radians, which is
   * a quarter turn (90˚).
   *
   * Note: `TWO_PI` radians equals 360˚, `PI` radians equals 180˚, `HALF_PI`
   * radians equals 90˚, and `QUARTER_PI` radians equals 45˚.
   *
   * @property {Number} HALF_PI
   * @final
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Draw an arc from 0 to HALF_PI.
   *   arc(50, 50, 80, 80, 0, HALF_PI);
   *
   *   describe('The bottom-right quarter of a circle drawn in white on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Translate the origin to the center.
   *   translate(50, 50);
   *
   *   // Draw a line.
   *   line(0, 0, 40, 0);
   *
   *   // Rotate a quarter turn.
   *   rotate(HALF_PI);
   *
   *   // Draw the same line, rotated.
   *   line(0, 0, 40, 0);
   *
   *   describe('Two black lines on a gray background. One line extends from the center to the right. The other line extends from the center to the bottom.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A red circle and a blue circle oscillate from left to right on a gray background. The red circle appears to chase the blue circle.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Translate the origin to the center.
   *   translate(50, 50);
   *
   *   // Calculate the x-coordinates.
   *   let x1 = 40 * sin(frameCount * 0.05);
   *   let x2 = 40 * sin(frameCount * 0.05 + HALF_PI);
   *
   *   // Style the oscillators.
   *   noStroke();
   *
   *   // Draw the red oscillator.
   *   fill(255, 0, 0);
   *   circle(x1, 0, 20);
   *
   *   // Draw the blue oscillator.
   *   fill(0, 0, 255);
   *   circle(x2, 0, 20);
   * }
   * </code>
   * </div>
   */
  const HALF_PI = _PI / 2;

  /**
   * A `Number` constant that's approximately 3.1416.
   *
   * `PI` is the mathematical constant π. It's useful for many tasks that
   * involve rotation and oscillation. For example, calling `rotate(PI)` rotates
   * the coordinate system `PI` radians, which is a half turn (180˚).
   *
   * Note: `TWO_PI` radians equals 360˚, `PI` radians equals 180˚, `HALF_PI`
   * radians equals 90˚, and `QUARTER_PI` radians equals 45˚.
   *
   * @property {Number} PI
   * @final
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Draw an arc from 0 to PI.
   *   arc(50, 50, 80, 80, 0, PI);
   *
   *   describe('The bottom half of a circle drawn in white on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Translate the origin to the center.
   *   translate(50, 50);
   *
   *   // Draw a line.
   *   line(0, 0, 40, 0);
   *
   *   // Rotate a half turn.
   *   rotate(PI);
   *
   *   // Draw the same line, rotated.
   *   line(0, 0, 40, 0);
   *
   *   describe('A horizontal black line on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A red circle and a blue circle oscillate from left to right on a gray background. The circles drift apart, then meet in the middle, over and over again.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Translate the origin to the center.
   *   translate(50, 50);
   *
   *   // Calculate the x-coordinates.
   *   let x1 = 40 * sin(frameCount * 0.05);
   *   let x2 = 40 * sin(frameCount * 0.05 + PI);
   *
   *   // Style the oscillators.
   *   noStroke();
   *
   *   // Draw the red oscillator.
   *   fill(255, 0, 0);
   *   circle(x1, 0, 20);
   *
   *   // Draw the blue oscillator.
   *   fill(0, 0, 255);
   *   circle(x2, 0, 20);
   * }
   * </code>
   * </div>
   */
  const PI = _PI;

  /**
   * A `Number` constant that's approximately 0.7854.
   *
   * `QUARTER_PI` is one-fourth the value of the mathematical constant π. It's
   * useful for many tasks that involve rotation and oscillation. For example,
   * calling `rotate(QUARTER_PI)` rotates the coordinate system `QUARTER_PI`
   * radians, which is an eighth of a turn (45˚).
   *
   * Note: `TWO_PI` radians equals 360˚, `PI` radians equals 180˚, `HALF_PI`
   * radians equals 90˚, and `QUARTER_PI` radians equals 45˚.
   *
   * @property {Number} QUARTER_PI
   * @final
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Draw an arc from 0 to QUARTER_PI.
   *   arc(50, 50, 80, 80, 0, QUARTER_PI);
   *
   *   describe('A one-eighth slice of a circle drawn in white on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Translate the origin to the center.
   *   translate(50, 50);
   *
   *   // Draw a line.
   *   line(0, 0, 40, 0);
   *
   *   // Rotate an eighth turn.
   *   rotate(QUARTER_PI);
   *
   *   // Draw the same line, rotated.
   *   line(0, 0, 40, 0);
   *
   *   describe('Two black lines that form a "V" opening towards the bottom-right corner of a gray square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A red circle and a blue circle oscillate from left to right on a gray background. The red circle appears to chase the blue circle.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Translate the origin to the center.
   *   translate(50, 50);
   *
   *   // Calculate the x-coordinates.
   *   let x1 = 40 * sin(frameCount * 0.05);
   *   let x2 = 40 * sin(frameCount * 0.05 + QUARTER_PI);
   *
   *   // Style the oscillators.
   *   noStroke();
   *
   *   // Draw the red oscillator.
   *   fill(255, 0, 0);
   *   circle(x1, 0, 20);
   *
   *   // Draw the blue oscillator.
   *   fill(0, 0, 255);
   *   circle(x2, 0, 20);
   * }
   * </code>
   * </div>
   */
  const QUARTER_PI = _PI / 4;

  /**
   * A `Number` constant that's approximately 6.2382.
   *
   * `TAU` is twice the value of the mathematical constant π. It's useful for
   * many tasks that involve rotation and oscillation. For example, calling
   * `rotate(TAU)` rotates the coordinate system `TAU` radians, which is one
   * full turn (360˚). `TAU` and `TWO_PI` are equal.
   *
   * Note: `TAU` radians equals 360˚, `PI` radians equals 180˚, `HALF_PI`
   * radians equals 90˚, and `QUARTER_PI` radians equals 45˚.
   *
   * @property {Number} TAU
   * @final
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Draw an arc from 0 to TAU.
   *   arc(50, 50, 80, 80, 0, TAU);
   *
   *   describe('A white circle drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Translate the origin to the center.
   *   translate(50, 50);
   *
   *   // Draw a line.
   *   line(0, 0, 40, 0);
   *
   *   // Rotate a full turn.
   *   rotate(TAU);
   *
   *   // Style the second line.
   *   strokeWeight(5);
   *
   *   // Draw the same line, shorter and rotated.
   *   line(0, 0, 20, 0);
   *
   *   describe(
   *     'Two horizontal black lines on a gray background. A thick line extends from the center toward the right. A thin line extends from the end of the thick line.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A red circle with a blue center oscillates from left to right on a gray background.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Translate the origin to the center.
   *   translate(50, 50);
   *
   *   // Calculate the x-coordinates.
   *   let x1 = 40 * sin(frameCount * 0.05);
   *   let x2 = 40 * sin(frameCount * 0.05 + TAU);
   *
   *   // Style the oscillators.
   *   noStroke();
   *
   *   // Draw the red oscillator.
   *   fill(255, 0, 0);
   *   circle(x1, 0, 20);
   *
   *   // Draw the blue oscillator, smaller.
   *   fill(0, 0, 255);
   *   circle(x2, 0, 10);
   * }
   * </code>
   * </div>
   */
  const TAU = _PI * 2;

  /**
   * A `Number` constant that's approximately 6.2382.
   *
   * `TWO_PI` is twice the value of the mathematical constant π. It's useful for
   * many tasks that involve rotation and oscillation. For example, calling
   * `rotate(TWO_PI)` rotates the coordinate system `TWO_PI` radians, which is
   * one full turn (360˚). `TWO_PI` and `TAU` are equal.
   *
   * Note: `TWO_PI` radians equals 360˚, `PI` radians equals 180˚, `HALF_PI`
   * radians equals 90˚, and `QUARTER_PI` radians equals 45˚.
   *
   * @property {Number} TWO_PI
   * @final
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Draw an arc from 0 to TWO_PI.
   *   arc(50, 50, 80, 80, 0, TWO_PI);
   *
   *   describe('A white circle drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Translate the origin to the center.
   *   translate(50, 50);
   *
   *   // Draw a line.
   *   line(0, 0, 40, 0);
   *
   *   // Rotate a full turn.
   *   rotate(TWO_PI);
   *
   *   // Style the second line.
   *   strokeWeight(5);
   *
   *   // Draw the same line, shorter and rotated.
   *   line(0, 0, 20, 0);
   *
   *   describe(
   *     'Two horizontal black lines on a gray background. A thick line extends from the center toward the right. A thin line extends from the end of the thick line.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A red circle with a blue center oscillates from left to right on a gray background.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Translate the origin to the center.
   *   translate(50, 50);
   *
   *   // Calculate the x-coordinates.
   *   let x1 = 40 * sin(frameCount * 0.05);
   *   let x2 = 40 * sin(frameCount * 0.05 + TWO_PI);
   *
   *   // Style the oscillators.
   *   noStroke();
   *
   *   // Draw the red oscillator.
   *   fill(255, 0, 0);
   *   circle(x1, 0, 20);
   *
   *   // Draw the blue oscillator, smaller.
   *   fill(0, 0, 255);
   *   circle(x2, 0, 10);
   * }
   * </code>
   * </div>
   */
  const TWO_PI = _PI * 2;

  /**
   * A `String` constant that's used to set the
   * <a href="#/p5/angleMode">angleMode()</a>.
   *
   * By default, functions such as <a href="#/p5/rotate">rotate()</a> and
   * <a href="#/p5/sin">sin()</a> expect angles measured in units of radians.
   * Calling `angleMode(DEGREES)` ensures that angles are measured in units of
   * degrees.
   *
   * Note: `TWO_PI` radians equals 360˚.
   *
   * @typedef {unique symbol} DEGREES
   * @property {DEGREES} DEGREES
   * @final
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Draw a red arc from 0 to HALF_PI radians.
   *   fill(255, 0, 0);
   *   arc(50, 50, 80, 80, 0, HALF_PI);
   *
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Draw a blue arc from 90˚ to 180˚.
   *   fill(0, 0, 255);
   *   arc(50, 50, 80, 80, 90, 180);
   *
   *   describe('The bottom half of a circle drawn on a gray background. The bottom-right quarter is red. The bottom-left quarter is blue.');
   * }
   * </code>
   * </div>
   */
  // export const DEGREES = Symbol('degrees');

  /**
   * A `String` constant that's used to set the
   * <a href="#/p5/angleMode">angleMode()</a>.
   *
   * By default, functions such as <a href="#/p5/rotate">rotate()</a> and
   * <a href="#/p5/sin">sin()</a> expect angles measured in units of radians.
   * Calling `angleMode(RADIANS)` ensures that angles are measured in units of
   * radians. Doing so can be useful if the
   * <a href="#/p5/angleMode">angleMode()</a> has been set to
   * <a href="#/p5/DEGREES">DEGREES</a>.
   *
   * Note: `TWO_PI` radians equals 360˚.
   *
   * @typedef {unique symbol} RADIANS
   * @property {RADIANS} RADIANS
   * @final
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Draw a red arc from 0˚ to 90˚.
   *   fill(255, 0, 0);
   *   arc(50, 50, 80, 80, 0, 90);
   *
   *   // Use radians.
   *   angleMode(RADIANS);
   *
   *   // Draw a blue arc from HALF_PI to PI.
   *   fill(0, 0, 255);
   *   arc(50, 50, 80, 80, HALF_PI, PI);
   *
   *   describe('The bottom half of a circle drawn on a gray background. The bottom-right quarter is red. The bottom-left quarter is blue.');
   * }
   * </code>
   * </div>
   */
  // export const RADIANS = Symbol('radians');
  const DEG_TO_RAD = _PI / 180.0;
  const RAD_TO_DEG = 180.0 / _PI;

  // SHAPE
  /**
   * @typedef {'corner'} CORNER
   * @property {CORNER} CORNER
   * @final
   */
  const CORNER = 'corner';
  /**
   * @typedef {'corners'} CORNERS
   * @property {CORNERS} CORNERS
   * @final
   */
  const CORNERS = 'corners';
  /**
   * @typedef {'radius'} RADIUS
   * @property {RADIUS} RADIUS
   * @final
   */
  const RADIUS = 'radius';
  /**
   * @typedef {'right'} RIGHT
   * @property {RIGHT} RIGHT
   * @final
   */
  const RIGHT = 'right';
  /**
   * @typedef {'left'} LEFT
   * @property {LEFT} LEFT
   * @final
   */
  const LEFT = 'left';
  /**
   * @typedef {'center'} CENTER
   * @property {CENTER} CENTER
   * @final
   */
  const CENTER = 'center';
  /**
   * @typedef {'top'} TOP
   * @property {TOP} TOP
   * @final
   */
  const TOP = 'top';
  /**
   * @typedef {'bottom'} BOTTOM
   * @property {BOTTOM} BOTTOM
   * @final
   */
  const BOTTOM = 'bottom';
  /**
   * @typedef {'alphabetic'} BASELINE
   * @property {BASELINE} BASELINE
   * @final
   */
  const BASELINE = 'alphabetic';
  /**
   * @typedef {0x0000} POINTS
   * @property {POINTS} POINTS
   * @final
   */
  const POINTS = 0x0000;
  /**
   * @typedef {0x0001} LINES
   * @property {LINES} LINES
   * @final
   */
  const LINES = 0x0001;
  /**
   * @property {0x0003} LINE_STRIP
   * @property {LINE_STRIP} LINE_STRIP
   * @final
   */
  const LINE_STRIP = 0x0003;
  /**
   * @typedef {0x0002} LINE_LOOP
   * @property {LINE_LOOP} LINE_LOOP
   * @final
   */
  const LINE_LOOP = 0x0002;
  /**
   * @typedef {0x0004} TRIANGLES
   * @property {TRIANGLES} TRIANGLES
   * @final
   */
  const TRIANGLES = 0x0004;
  /**
   * @typedef {0x0006} TRIANGLE_FAN
   * @property {TRIANGLE_FAN} TRIANGLE_FAN
   * @final
   */
  const TRIANGLE_FAN = 0x0006;
  /**
   * @typedef {0x0005} TRIANGLE_STRIP
   * @property {TRIANGLE_STRIP} TRIANGLE_STRIP
   * @final
   */
  const TRIANGLE_STRIP = 0x0005;
  /**
   * @typedef {'quads'} QUADS
   * @property {QUADS} QUADS
   * @final
   */
  const QUADS = 'quads';
  /**
   * @typedef {'quad_strip'} QUAD_STRIP
   * @property {QUAD_STRIP} QUAD_STRIP
   * @final
   */
  const QUAD_STRIP = 'quad_strip';
  /**
   * @typedef {'tess'} TESS
   * @property {TESS} TESS
   * @final
   */
  const TESS = 'tess';
  /**
   * @typedef {0x0007} EMPTY_PATH
   * @property {EMPTY_PATH} EMPTY_PATH
   * @final
   */
  const EMPTY_PATH = 0x0007;
  /**
   * @typedef {0x0008} PATH
   * @property {PATH} PATH
   * @final
   */
  const PATH = 0x0008;
  /**
   * @typedef {'close'} CLOSE
   * @property {CLOSE} CLOSE
   * @final
   */
  const CLOSE = 'close';
  /**
   * @typedef {'open'} OPEN
   * @property {OPEN} OPEN
   * @final
   */
  const OPEN = 'open';
  /**
   * @typedef {'chord'} CHORD
   * @property {CHORD} CHORD
   * @final
   */
  const CHORD = 'chord';
  /**
   * @typedef {'pie'} PIE
   * @property {PIE} PIE
   * @final
   */
  const PIE = 'pie';
  /**
   * @typedef {'square'} PROJECT
   * @property {PROJECT} PROJECT
   * @final
   */
  const PROJECT = 'square'; // PEND: careful this is counterintuitive
  /**
   * @typedef {'butt'} SQUARE
   * @property {SQUERE} SQUARE
   * @final
   */
  const SQUARE = 'butt';
  /**
   * @typedef {'round'} ROUND
   * @property {ROUND} ROUND
   * @final
   */
  const ROUND = 'round';
  /**
   * @typedef {'bevel'} BEVEL
   * @property {BEVEL} BEVEL
   * @final
   */
  const BEVEL = 'bevel';
  /**
   * @typedef {'miter'} MITER
   * @property {MITER} MITER
   * @final
   */
  const MITER = 'miter';

  // DOM EXTENSION
  /**
   * AUTO allows us to automatically set the width or height of an element (but not both),
   * based on the current height and width of the element. Only one parameter can
   * be passed to the <a href="/reference/p5.Element/size">size</a> function as AUTO, at a time.
   *
   * @typedef {'auto'} AUTO
   * @property {AUTO} AUTO
   * @final
   */
  const AUTO = 'auto';
  // INPUT
  /**
   * @typedef {'Alt'} ALT
   * @property {ALT} ALT
   * @final
   */
  const ALT = 'Alt';

  /**
   * @typedef {'Backspace'} BACKSPACE
   * @property {BACKSPACE} BACKSPACE
   * @final
   */
  const BACKSPACE = 'Backspace';

  /**
   * @typedef {'Control' | 'Control'} CONTROL
   * @property {CONTROL} CONTROL
   * @final
   */
  const CONTROL = 'Control';

  /**
   * @typedef {'Delete'} DELETE
   * @property {DELETE} DELETE
   * @final
   */
  const DELETE = 'Delete';

  /**
   * @typedef {'ArrowDown'} DOWN_ARROW
   * @property {DOWN_ARROW} DOWN_ARROW
   * @final
   */
  const DOWN_ARROW = 'ArrowDown';

  /**
   * @typedef {'Enter'} ENTER
   * @property {ENTER} ENTER
   * @final
   */
  const ENTER = 'Enter';

  /**
   * @typedef {'Escape'} ESCAPE
   * @property {ESCAPE} ESCAPE
   * @final
   */
  const ESCAPE = 'Escape';

  /**
   * @typedef {'ArrowLeft'} LEFT_ARROW
   * @property {LEFT_ARROW} LEFT_ARROW
   * @final
   */
  const LEFT_ARROW = 'ArrowLeft';

  /**
   * @typedef {'Alt'} OPTION
   * @property {OPTION} OPTION
   * @final
   */
  const OPTION = 'Alt';

  /**
   * @typedef {'Enter'} RETURN
   * @property {RETURN} RETURN
   * @final
   */
  const RETURN = 'Enter';

  /**
   * @typedef {'ArrowRight'} RIGHT_ARROW
   * @property {RIGHT_ARROW} RIGHT_ARROW
   * @final
   */
  const RIGHT_ARROW = 'ArrowRight';

  /**
   * @typedef {'Shift'} SHIFT
   * @property {SHIFT} SHIFT
   * @final
   */
  const SHIFT = 'Shift';

  /**
   * @typedef {'Tab'} TAB
   * @property {TAB} TAB
   * @final
   */
  const TAB = 'Tab';

  /**
   * @typedef {'ArrowUp'} UP_ARROW
   * @property {UP_ARROW} UP_ARROW
   * @final
   */
  const UP_ARROW = 'ArrowUp';

  // RENDERING
  /**
   * @typedef {'source-over'} BLEND
   * @property {BLEND} BLEND
   * @final
   */
  const BLEND = 'source-over';
  /**
   * @typedef {'destination-out'} REMOVE
   * @property {REMOVE} REMOVE
   * @final
   */
  const REMOVE = 'destination-out';
  /**
   * @typedef {'lighter'} ADD
   * @property {ADD} ADD
   * @final
   */
  const ADD = 'lighter';
  /**
   * @typedef {'darken'} DARKEST
   * @property {DARKEST} DARKEST
   * @final
   */
  const DARKEST = 'darken';
  /**
   * @typedef {'lighten'} LIGHTEST
   * @property {LIGHTEST} LIGHTEST
   * @final
   */
  const LIGHTEST = 'lighten';
  /**
   * @typedef {'difference'} DIFFERENCE
   * @property {DIFFERENCE} DIFFERENCE
   * @final
   */
  const DIFFERENCE = 'difference';
  /**
   * @typedef {'subtract'} SUBTRACT
   * @property {SUBTRACT} SUBTRACT
   * @final
   */
  const SUBTRACT = 'subtract';
  /**
   * @typedef {'exclusion'} EXCLUSION
   * @property {EXCLUSION} EXCLUSION
   * @final
   */
  const EXCLUSION = 'exclusion';
  /**
   * @typedef {'multiply'} MULTIPLY
   * @property {MULTIPLY} MULTIPLY
   * @final
   */
  const MULTIPLY = 'multiply';
  /**
   * @typedef {'screen'} SCREEN
   * @property {SCREEN} SCREEN
   * @final
   */
  const SCREEN = 'screen';
  /**
   * @typedef {'copy'} REPLACE
   * @property {REPLACE} REPLACE
   * @final
   */
  const REPLACE = 'copy';
  /**
   * @typedef {'overlay'} OVERLAY
   * @property {OVERLAY} OVERLAY
   * @final
   */
  const OVERLAY = 'overlay';
  /**
   * @typedef {'hard-light'} HARD_LIGHT
   * @property {HARD_LIGHT} HARD_LIGHT
   * @final
   */
  const HARD_LIGHT = 'hard-light';
  /**
   * @typedef {'soft-light'} SOFT_LIGHT
   * @property {SOFT_LIGHT} SOFT_LIGHT
   * @final
   */
  const SOFT_LIGHT = 'soft-light';
  /**
   * @typedef {'color-dodge'} DODGE
   * @property {DODGE} DODGE
   * @final
   */
  const DODGE = 'color-dodge';
  /**
   * @typedef {'color-burn'} BURN
   * @property {BURN} BURN
   * @final
   */
  const BURN = 'color-burn';

  // FILTERS
  /**
   * @typedef {'threshold'} THRESHOLD
   * @property {THRESHOLD} THRESHOLD
   * @final
   */
  const THRESHOLD = 'threshold';
  /**
   * @typedef {'gray'} GRAY
   * @property {GRAY} GRAY
   * @final
   */
  const GRAY = 'gray';
  /**
   * @typedef {'opaque'} OPAQUE
   * @property {OPAQUE} OPAQUE
   * @final
   */
  const OPAQUE = 'opaque';
  /**
   * @typedef {'invert'} INVERT
   * @property {INVERT} INVERT
   * @final
   */
  const INVERT = 'invert';
  /**
   * @typedef {'posterize'} POSTERIZE
   * @property {POSTERIZE} POSTERIZE
   * @final
   */
  const POSTERIZE = 'posterize';
  /**
   * @typedef {'dilate'} DILATE
   * @property {DILATE} DILATE
   * @final
   */
  const DILATE = 'dilate';
  /**
   * @typedef {'erode'} ERODE
   * @property {ERODE} ERODE
   * @final
   */
  const ERODE = 'erode';
  /**
   * @typedef {'blur'} BLUR
   * @property {BLUR} BLUR
   * @final
   */
  const BLUR = 'blur';

  // TYPOGRAPHY
  /**
   * @typedef {'normal'} NORMAL
   * @property {NORMAL} NORMAL
   * @final
   */
  const NORMAL = 'normal';
  /**
   * @typedef {'italic'} ITALIC
   * @property {ITALIC} ITALIC
   * @final
   */
  const ITALIC = 'italic';
  /**
   * @typedef {'bold'} BOLD
   * @property {BOLD} BOLD
   * @final
   */
  const BOLD = 'bold';
  /**
   * @typedef {'bold italic'} BOLDITALIC
   * @property {BOLDITALIC} BOLDITALIC
   * @final
   */
  const BOLDITALIC = 'bold italic';
  /**
   * @typedef {'CHAR'} CHAR
   * @property {CHAR} CHAR
   * @final
   */
  const CHAR = 'CHAR';
  /**
   * @typedef {'WORD'} WORD
   * @property {WORD} WORD
   * @final
   */
  const WORD = 'WORD';

  // TYPOGRAPHY-INTERNAL
  const _DEFAULT_TEXT_FILL = '#000000';
  const _DEFAULT_LEADMULT = 1.25;
  const _CTX_MIDDLE = 'middle';

  // VERTICES
  /**
   * @typedef {'linear'} LINEAR
   * @property {LINEAR} LINEAR
   * @final
   */
  const LINEAR = 'linear';
  /**
   * @typedef {'quadratic'} QUADRATIC
   * @property {QUADRATIC} QUADRATIC
   * @final
   */
  const QUADRATIC = 'quadratic';
  /**
   * @typedef {'bezier'} BEZIER
   * @property {BEZIER} BEZIER
   * @final
   */
  const BEZIER = 'bezier';
  /**
   * @typedef {'curve'} CURVE
   * @property {CURVE} CURVE
   * @final
   */
  const CURVE = 'curve';

  // WEBGL DRAWMODES
  /**
   * @typedef {'stroke'} STROKE
   * @property {STROKE} STROKE
   * @final
   */
  const STROKE = 'stroke';
  /**
   * @typedef {'fill'} FILL
   * @property {FILL} FILL
   * @final
   */
  const FILL = 'fill';
  /**
   * @typedef {'texture'} TEXTURE
   * @property {TEXTURE} TEXTURE
   * @final
   */
  const TEXTURE = 'texture';
  /**
   * @typedef {'immediate'} IMMEDIATE
   * @property {IMMEDIATE} IMMEDIATE
   * @final
   */
  const IMMEDIATE = 'immediate';

  // WEBGL TEXTURE MODE
  // NORMAL already exists for typography
  /**
   * @typedef {'image'} IMAGE
   * @property {IMAGE} IMAGE
   * @final
   */
  const IMAGE = 'image';

  // WEBGL TEXTURE WRAP AND FILTERING
  // LINEAR already exists above
  /**
   * @typedef {'nearest'} NEAREST
   * @property {NEAREST} NEAREST
   * @final
   */
  const NEAREST = 'nearest';
  /**
   * @typedef {'repeat'} REPEAT
   * @property {REPEAT} REPEAT
   * @final
   */
  const REPEAT = 'repeat';
  /**
   * @typedef {'clamp'} CLAMP
   * @property {CLAMP} CLAMP
   * @final
   */
  const CLAMP = 'clamp';
  /**
   * @typedef {'mirror'} MIRROR
   * @property {MIRROR} MIRROR
   * @final
   */
  const MIRROR = 'mirror';

  // WEBGL GEOMETRY SHADING
  /**
   * @typedef {'flat'} FLAT
   * @property {FLAT} FLAT
   * @final
   */
  const FLAT = 'flat';
  /**
   * @typedef {'smooth'} SMOOTH
   * @property {SMOOTH} SMOOTH
   * @final
   */
  const SMOOTH = 'smooth';

  // DEVICE-ORIENTATION
  /**
   * @typedef {'landscape'} LANDSCAPE
   * @property {LANDSCAPE} LANDSCAPE
   * @final
   */
  const LANDSCAPE = 'landscape';
  /**
   * @typedef {'portrait'} PORTRAIT
   * @property {PORTRAIT} PORTRAIT
   * @final
   */
  const PORTRAIT = 'portrait';

  // DEFAULTS
  const _DEFAULT_STROKE = '#000000';
  const _DEFAULT_FILL = '#FFFFFF';

  /**
   * @typedef {'grid'} GRID
   * @property {GRID} GRID
   * @final
   */
  const GRID = 'grid';

  /**
   * @typedef {'axes'} AXES
   * @property {AXES} AXES
   * @final
   */
  const AXES = 'axes';

  /**
   * @typedef {'label'} LABEL
   * @property {LABEL} LABEL
   * @final
   */
  const LABEL = 'label';
  /**
   * @typedef {'fallback'} FALLBACK
   * @property {FALLBACK} FALLBACK
   * @final
   */
  const FALLBACK = 'fallback';

  /**
   * @typedef {'contain'} CONTAIN
   * @property {CONTAIN} CONTAIN
   * @final
   */
  const CONTAIN = 'contain';

  /**
   * @typedef {'cover'} COVER
   * @property {COVER} COVER
   * @final
   */
  const COVER = 'cover';

  /**
   * @typedef {'unsigned-byte'} UNSIGNED_BYTE
   * @property {UNSIGNED_BYTE} UNSIGNED_BYTE
   * @final
   */
  const UNSIGNED_BYTE = 'unsigned-byte';

  /**
   * @typedef {'unsigned-int'} UNSIGNED_INT
   * @property {UNSIGNED_INT} UNSIGNED_INT
   * @final
   */
  const UNSIGNED_INT = 'unsigned-int';

  /**
   * @typedef {'float'} FLOAT
   * @property {FLOAT} FLOAT
   * @final
   */
  const FLOAT = 'float';

  /**
   * @typedef {'half-float'} HALF_FLOAT
   * @property {HALF_FLOAT} HALF_FLOAT
   * @final
   */
  const HALF_FLOAT = 'half-float';

  /**
   * The `splineProperty('ends')` mode where splines curve through
   * their first and last points.
   * @typedef {unique symbol} INCLUDE
   * @property {INCLUDE} INCLUDE
   * @final
   */
  const INCLUDE = Symbol('include');

  /**
   * The `splineProperty('ends')` mode where the first and last points in a spline
   * affect the direction of the curve, but are not rendered.
   * @typedef {unique symbol} EXCLUDE
   * @property {EXCLUDE} EXCLUDE
   * @final
   */
  const EXCLUDE = Symbol('exclude');

  /**
   * The `splineProperty('ends')` mode where the spline loops back to its first point.
   * Only used internally.
   * @typedef {unique symbol} JOIN
   * @property {JOIN} JOIN
   * @final
   * @private
   */
  const JOIN = Symbol('join');

  var constants = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ADD: ADD,
    ALT: ALT,
    ARROW: ARROW,
    AUTO: AUTO,
    AXES: AXES,
    BACKSPACE: BACKSPACE,
    BASELINE: BASELINE,
    BEVEL: BEVEL,
    BEZIER: BEZIER,
    BLEND: BLEND,
    BLUR: BLUR,
    BOLD: BOLD,
    BOLDITALIC: BOLDITALIC,
    BOTTOM: BOTTOM,
    BURN: BURN,
    CENTER: CENTER,
    CHAR: CHAR,
    CHORD: CHORD,
    CLAMP: CLAMP,
    CLOSE: CLOSE,
    CONTAIN: CONTAIN,
    CONTROL: CONTROL,
    CORNER: CORNER,
    CORNERS: CORNERS,
    COVER: COVER,
    CROSS: CROSS,
    CURVE: CURVE,
    DARKEST: DARKEST,
    DEG_TO_RAD: DEG_TO_RAD,
    DELETE: DELETE,
    DIFFERENCE: DIFFERENCE,
    DILATE: DILATE,
    DODGE: DODGE,
    DOWN_ARROW: DOWN_ARROW,
    EMPTY_PATH: EMPTY_PATH,
    ENTER: ENTER,
    ERODE: ERODE,
    ESCAPE: ESCAPE,
    EXCLUDE: EXCLUDE,
    EXCLUSION: EXCLUSION,
    FALLBACK: FALLBACK,
    FILL: FILL,
    FLAT: FLAT,
    FLOAT: FLOAT,
    FULL: FULL,
    GRAY: GRAY,
    GRID: GRID,
    HALF_FLOAT: HALF_FLOAT,
    HALF_PI: HALF_PI,
    HAND: HAND,
    HARD_LIGHT: HARD_LIGHT,
    IMAGE: IMAGE,
    IMMEDIATE: IMMEDIATE,
    INCLUDE: INCLUDE,
    INVERT: INVERT,
    ITALIC: ITALIC,
    JOIN: JOIN,
    LABEL: LABEL,
    LANDSCAPE: LANDSCAPE,
    LEFT: LEFT,
    LEFT_ARROW: LEFT_ARROW,
    LIGHTEST: LIGHTEST,
    LINEAR: LINEAR,
    LINES: LINES,
    LINE_LOOP: LINE_LOOP,
    LINE_STRIP: LINE_STRIP,
    MIRROR: MIRROR,
    MITER: MITER,
    MOVE: MOVE,
    MULTIPLY: MULTIPLY,
    NEAREST: NEAREST,
    NORMAL: NORMAL,
    OPAQUE: OPAQUE,
    OPEN: OPEN,
    OPTION: OPTION,
    OVERLAY: OVERLAY,
    P2D: P2D,
    P2DHDR: P2DHDR,
    PATH: PATH,
    PI: PI,
    PIE: PIE,
    POINTS: POINTS,
    PORTRAIT: PORTRAIT,
    POSTERIZE: POSTERIZE,
    PROJECT: PROJECT,
    QUADRATIC: QUADRATIC,
    QUADS: QUADS,
    QUAD_STRIP: QUAD_STRIP,
    QUARTER_PI: QUARTER_PI,
    RADIUS: RADIUS,
    RAD_TO_DEG: RAD_TO_DEG,
    REMOVE: REMOVE,
    REPEAT: REPEAT,
    REPLACE: REPLACE,
    RETURN: RETURN,
    RIGHT: RIGHT,
    RIGHT_ARROW: RIGHT_ARROW,
    ROUND: ROUND,
    SCREEN: SCREEN,
    SHIFT: SHIFT,
    SIMPLE: SIMPLE,
    SMOOTH: SMOOTH,
    SOFT_LIGHT: SOFT_LIGHT,
    SQUARE: SQUARE,
    STROKE: STROKE,
    SUBTRACT: SUBTRACT,
    TAB: TAB,
    TAU: TAU,
    TESS: TESS,
    TEXT: TEXT,
    TEXTURE: TEXTURE,
    THRESHOLD: THRESHOLD,
    TOP: TOP,
    TRIANGLES: TRIANGLES,
    TRIANGLE_FAN: TRIANGLE_FAN,
    TRIANGLE_STRIP: TRIANGLE_STRIP,
    TWO_PI: TWO_PI,
    UNSIGNED_BYTE: UNSIGNED_BYTE,
    UNSIGNED_INT: UNSIGNED_INT,
    UP_ARROW: UP_ARROW,
    VERSION: VERSION,
    WAIT: WAIT,
    WEBGL: WEBGL,
    WEBGL2: WEBGL2,
    WORD: WORD,
    _CTX_MIDDLE: _CTX_MIDDLE,
    _DEFAULT_FILL: _DEFAULT_FILL,
    _DEFAULT_LEADMULT: _DEFAULT_LEADMULT,
    _DEFAULT_STROKE: _DEFAULT_STROKE,
    _DEFAULT_TEXT_FILL: _DEFAULT_TEXT_FILL
  });

  /**
   * @module Transform
   * @submodule Transform
   * @for p5
   * @requires core
   * @requires constants
   */

  function transform$1(p5, fn){
    /**
     * Applies a transformation matrix to the coordinate system.
     *
     * Transformations such as
     * <a href="#/p5/translate">translate()</a>,
     * <a href="#/p5/rotate">rotate()</a>, and
     * <a href="#/p5/scale">scale()</a>
     * use matrix-vector multiplication behind the scenes. A table of numbers,
     * called a matrix, encodes each transformation. The values in the matrix
     * then multiply each point on the canvas, which is represented by a vector.
     *
     * `applyMatrix()` allows for many transformations to be applied at once. See
     * <a href="https://en.wikipedia.org/wiki/Transformation_matrix" target="_blank">Wikipedia</a>
     * and <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Matrix_math_for_the_web" target="_blank">MDN</a>
     * for more details about transformations.
     *
     * There are two ways to call `applyMatrix()` in two and three dimensions.
     *
     * In 2D mode, the parameters `a`, `b`, `c`, `d`, `e`, and `f`, correspond to
     * elements in the following transformation matrix:
     *
     * > <img style="max-width: 150px" src="assets/transformation-matrix.png"
     * alt="The transformation matrix used when applyMatrix is called in 2D mode."/>
     *
     * The numbers can be passed individually, as in
     * `applyMatrix(2, 0, 0, 0, 2, 0)`. They can also be passed in an array, as in
     * `applyMatrix([2, 0, 0, 0, 2, 0])`.
     *
     * In 3D mode, the parameters `a`, `b`, `c`, `d`, `e`, `f`, `g`, `h`, `i`,
     * `j`, `k`, `l`, `m`, `n`, `o`, and `p` correspond to elements in the
     * following transformation matrix:
     *
     * <img style="max-width: 300px" src="assets/transformation-matrix-4-4.png"
     * alt="The transformation matrix used when applyMatrix is called in 3D mode."/>
     *
     * The numbers can be passed individually, as in
     * `applyMatrix(2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1)`. They can
     * also be passed in an array, as in
     * `applyMatrix([2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1])`.
     *
     * By default, transformations accumulate. The
     * <a href="#/p5/push">push()</a> and <a href="#/p5/pop">pop()</a> functions
     * can be used to isolate transformations within distinct drawing groups.
     *
     * Note: Transformations are reset at the beginning of the draw loop. Calling
     * `applyMatrix()` inside the <a href="#/p5/draw">draw()</a> function won't
     * cause shapes to transform continuously.
     *
     * @method applyMatrix
     * @param  {Array} arr an array containing the elements of the transformation matrix. Its length should be either 6 (2D) or 16 (3D).
     * @chainable
     *
     * @example
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   describe('A white circle on a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Translate the origin to the center.
     *   applyMatrix(1, 0, 0, 1, 50, 50);
     *
     *   // Draw the circle at coordinates (0, 0).
     *   circle(0, 0, 40);
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   describe('A white circle on a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Translate the origin to the center.
     *   let m = [1, 0, 0, 1, 50, 50];
     *   applyMatrix(m);
     *
     *   // Draw the circle at coordinates (0, 0).
     *   circle(0, 0, 40);
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   describe("A white rectangle on a gray background. The rectangle's long axis runs from top-left to bottom-right.");
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Rotate the coordinate system 1/8 turn.
     *   let angle = QUARTER_PI;
     *   let ca = cos(angle);
     *   let sa = sin(angle);
     *   applyMatrix(ca, sa, -sa, ca, 0, 0);
     *
     *   // Draw a rectangle at coordinates (50, 0).
     *   rect(50, 0, 40, 20);
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   describe(
     *     'Two white squares on a gray background. The larger square appears at the top-center. The smaller square appears at the top-left.'
     *   );
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Draw a square at (30, 20).
     *   square(30, 20, 40);
     *
     *   // Scale the coordinate system by a factor of 0.5.
     *   applyMatrix(0.5, 0, 0, 0.5, 0, 0);
     *
     *   // Draw a square at (30, 20).
     *   // It appears at (15, 10) after scaling.
     *   square(30, 20, 40);
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   describe('A white quadrilateral on a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Calculate the shear factor.
     *   let angle = QUARTER_PI;
     *   let shearFactor = 1 / tan(HALF_PI - angle);
     *
     *   // Shear the coordinate system along the x-axis.
     *   applyMatrix(1, 0, shearFactor, 1, 0, 0);
     *
     *   // Draw the square.
     *   square(0, 0, 50);
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * // Click and drag the mouse to view the scene from different angles.
     *
     * function setup() {
     *   createCanvas(100, 100, WEBGL);
     *
     *   describe('A white cube rotates slowly against a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Enable orbiting with the mouse.
     *   orbitControl();
     *
     *   // Rotate the coordinate system a little more each frame.
     *   let angle = frameCount * 0.01;
     *   let ca = cos(angle);
     *   let sa = sin(angle);
     *   applyMatrix(ca, 0, sa, 0, 0, 1, 0, 0, -sa, 0, ca, 0, 0, 0, 0, 1);
     *
     *   // Draw a box.
     *   box();
     * }
     * </code>
     * </div>
     */
    /**
     * @method applyMatrix
     * @param  {Number} a an element of the transformation matrix.
     * @param  {Number} b an element of the transformation matrix.
     * @param  {Number} c an element of the transformation matrix.
     * @param  {Number} d an element of the transformation matrix.
     * @param  {Number} e an element of the transformation matrix.
     * @param  {Number} f an element of the transformation matrix.
     * @chainable
     */
    /**
     * @method applyMatrix
     * @param  {Number} a
     * @param  {Number} b
     * @param  {Number} c
     * @param  {Number} d
     * @param  {Number} e
     * @param  {Number} f
     * @param  {Number} g an element of the transformation matrix.
     * @param  {Number} h an element of the transformation matrix.
     * @param  {Number} i an element of the transformation matrix.
     * @param  {Number} j an element of the transformation matrix.
     * @param  {Number} k an element of the transformation matrix.
     * @param  {Number} l an element of the transformation matrix.
     * @param  {Number} m an element of the transformation matrix.
     * @param  {Number} n an element of the transformation matrix.
     * @param  {Number} o an element of the transformation matrix.
     * @param  {Number} p an element of the transformation matrix.
     * @chainable
     */
    fn.applyMatrix = function(...args) {
      let isTypedArray = args[0] instanceof Object.getPrototypeOf(Uint8Array);
      if (Array.isArray(args[0]) || isTypedArray) {
        this._renderer.applyMatrix(...args[0]);
      } else {
        this._renderer.applyMatrix(...args);
      }
      return this;
    };

    /**
     * Clears all transformations applied to the coordinate system.
     *
     * @method resetMatrix
     * @chainable
     *
     * @example
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   describe(
     *     'Two circles drawn on a gray background. A blue circle is at the top-left and a red circle is at the bottom-right.'
     *   );
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Translate the origin to the center.
     *   translate(50, 50);
     *
     *   // Draw a blue circle at the coordinates (25, 25).
     *   fill('blue');
     *   circle(25, 25, 20);
     *
     *   // Clear all transformations.
     *   // The origin is now at the top-left corner.
     *   resetMatrix();
     *
     *   // Draw a red circle at the coordinates (25, 25).
     *   fill('red');
     *   circle(25, 25, 20);
     * }
     * </code>
     * </div>
     */
    fn.resetMatrix = function() {
      this._renderer.resetMatrix();
      return this;
    };

    /**
     * Rotates the coordinate system.
     *
     * By default, the positive x-axis points to the right and the positive y-axis
     * points downward. The `rotate()` function changes this orientation by
     * rotating the coordinate system about the origin. Everything drawn after
     * `rotate()` is called will appear to be rotated.
     *
     * The first parameter, `angle`, is the amount to rotate. For example, calling
     * `rotate(1)` rotates the coordinate system clockwise 1 radian which is
     * nearly 57˚. `rotate()` interprets angle values using the current
     * <a href="#/p5/angleMode">angleMode()</a>.
     *
     * The second parameter, `axis`, is optional. It's used to orient 3D rotations
     * in WebGL mode. If a <a href="#/p5.Vector">p5.Vector</a> is passed, as in
     * `rotate(QUARTER_PI, myVector)`, then the coordinate system will rotate
     * `QUARTER_PI` radians about `myVector`. If an array of vector components is
     * passed, as in `rotate(QUARTER_PI, [1, 0, 0])`, then the coordinate system
     * will rotate `QUARTER_PI` radians about a vector with the components
     * `[1, 0, 0]`.
     *
     * By default, transformations accumulate. For example, calling `rotate(1)`
     * twice has the same effect as calling `rotate(2)` once. The
     * <a href="#/p5/push">push()</a> and <a href="#/p5/pop">pop()</a> functions
     * can be used to isolate transformations within distinct drawing groups.
     *
     * Note: Transformations are reset at the beginning of the draw loop. Calling
     * `rotate(1)` inside the <a href="#/p5/draw">draw()</a> function won't cause
     * shapes to spin.
     *
     * @method rotate
     * @param  {Number} angle angle of rotation in the current <a href="#/p5/angleMode">angleMode()</a>.
     * @param  {p5.Vector|Number[]} [axis] axis to rotate about in 3D.
     * @chainable
     *
     * @example
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   describe(
     *     "A white rectangle on a gray background. The rectangle's long axis runs from top-left to bottom-right."
     *   );
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Rotate the coordinate system 1/8 turn.
     *   rotate(QUARTER_PI);
     *
     *   // Draw a rectangle at coordinates (50, 0).
     *   rect(50, 0, 40, 20);
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   describe(
     *     "A white rectangle on a gray background. The rectangle's long axis runs from top-left to bottom-right."
     *   );
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Rotate the coordinate system 1/16 turn.
     *   rotate(QUARTER_PI / 2);
     *
     *   // Rotate the coordinate system another 1/16 turn.
     *   rotate(QUARTER_PI / 2);
     *
     *   // Draw a rectangle at coordinates (50, 0).
     *   rect(50, 0, 40, 20);
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   // Use degrees.
     *   angleMode(DEGREES);
     *
     *   describe(
     *     "A white rectangle on a gray background. The rectangle's long axis runs from top-left to bottom-right."
     *   );
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Rotate the coordinate system 1/8 turn.
     *   rotate(45);
     *
     *   // Draw a rectangle at coordinates (50, 0).
     *   rect(50, 0, 40, 20);
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   describe(
     *     'A white rectangle on a gray background. The rectangle rotates slowly about the top-left corner. It disappears and reappears periodically.'
     *   );
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Rotate the coordinate system a little more each frame.
     *   let angle = frameCount * 0.01;
     *   rotate(angle);
     *
     *   // Draw a rectangle at coordinates (50, 0).
     *   rect(50, 0, 40, 20);
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100, WEBGL);
     *
     *   describe("A cube on a gray background. The cube's front face points to the top-right.");
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Rotate the coordinate system 1/8 turn about
     *   // the axis [1, 1, 0].
     *   let axis = createVector(1, 1, 0);
     *   rotate(QUARTER_PI, axis);
     *
     *   // Draw a box.
     *   box();
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100, WEBGL);
     *
     *   describe("A cube on a gray background. The cube's front face points to the top-right.");
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Rotate the coordinate system 1/8 turn about
     *   // the axis [1, 1, 0].
     *   let axis = [1, 1, 0];
     *   rotate(QUARTER_PI, axis);
     *
     *   // Draw a box.
     *   box();
     * }
     * </code>
     * </div>
     */
    fn.rotate = function(angle, axis) {
      // p5._validateParameters('rotate', arguments);
      this._renderer.rotate(this._toRadians(angle), axis);
      return this;
    };

    /**
     * Rotates the coordinate system about the x-axis in WebGL mode.
     *
     * The parameter, `angle`, is the amount to rotate. For example, calling
     * `rotateX(1)` rotates the coordinate system about the x-axis by 1 radian.
     * `rotateX()` interprets angle values using the current
     * <a href="#/p5/angleMode">angleMode()</a>.
     *
     * By default, transformations accumulate. For example, calling `rotateX(1)`
     * twice has the same effect as calling `rotateX(2)` once. The
     * <a href="#/p5/push">push()</a> and <a href="#/p5/pop">pop()</a> functions
     * can be used to isolate transformations within distinct drawing groups.
     *
     * Note: Transformations are reset at the beginning of the draw loop. Calling
     * `rotateX(1)` inside the <a href="#/p5/draw">draw()</a> function won't cause
     * shapes to spin.
     *
     * @method  rotateX
     * @param  {Number} angle angle of rotation in the current <a href="#/p5/angleMode">angleMode()</a>.
     * @chainable
     *
     * @example
     * <div>
     * <code>
     * // Click and drag the mouse to view the scene from different angles.
     *
     * function setup() {
     *   createCanvas(100, 100, WEBGL);
     *
     *   describe('A white cube on a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Enable orbiting with the mouse.
     *   orbitControl();
     *
     *   // Rotate the coordinate system 1/8 turn.
     *   rotateX(QUARTER_PI);
     *
     *   // Draw a box.
     *   box();
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * // Click and drag the mouse to view the scene from different angles.
     *
     * function setup() {
     *   createCanvas(100, 100, WEBGL);
     *
     *   describe('A white cube on a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Enable orbiting with the mouse.
     *   orbitControl();
     *
     *   // Rotate the coordinate system 1/16 turn.
     *   rotateX(QUARTER_PI / 2);
     *
     *   // Rotate the coordinate system 1/16 turn.
     *   rotateX(QUARTER_PI / 2);
     *
     *   // Draw a box.
     *   box();
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * // Click and drag the mouse to view the scene from different angles.
     *
     * function setup() {
     *   createCanvas(100, 100, WEBGL);
     *
     *   // Use degrees.
     *   angleMode(DEGREES);
     *
     *   describe('A white cube on a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Enable orbiting with the mouse.
     *   orbitControl();
     *
     *   // Rotate the coordinate system 1/8 turn.
     *   rotateX(45);
     *
     *   // Draw a box.
     *   box();
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * // Click and drag the mouse to view the scene from different angles.
     *
     * function setup() {
     *   createCanvas(100, 100, WEBGL);
     *
     *   describe('A white cube rotates slowly against a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Enable orbiting with the mouse.
     *   orbitControl();
     *
     *   // Rotate the coordinate system a little more each frame.
     *   let angle = frameCount * 0.01;
     *   rotateX(angle);
     *
     *   // Draw a box.
     *   box();
     * }
     * </code>
     * </div>
     */
    fn.rotateX = function(angle) {
      this._assert3d('rotateX');
      // p5._validateParameters('rotateX', arguments);
      this._renderer.rotateX(this._toRadians(angle));
      return this;
    };

    /**
     * Rotates the coordinate system about the y-axis in WebGL mode.
     *
     * The parameter, `angle`, is the amount to rotate. For example, calling
     * `rotateY(1)` rotates the coordinate system about the y-axis by 1 radian.
     * `rotateY()` interprets angle values using the current
     * <a href="#/p5/angleMode">angleMode()</a>.
     *
     * By default, transformations accumulate. For example, calling `rotateY(1)`
     * twice has the same effect as calling `rotateY(2)` once. The
     * <a href="#/p5/push">push()</a> and <a href="#/p5/pop">pop()</a> functions
     * can be used to isolate transformations within distinct drawing groups.
     *
     * Note: Transformations are reset at the beginning of the draw loop. Calling
     * `rotateY(1)` inside the <a href="#/p5/draw">draw()</a> function won't cause
     * shapes to spin.
     *
     * @method rotateY
     * @param  {Number} angle angle of rotation in the current <a href="#/p5/angleMode">angleMode()</a>.
     * @chainable
     *
     * @example
     * <div>
     * <code>
     * // Click and drag the mouse to view the scene from different angles.
     *
     * function setup() {
     *   createCanvas(100, 100, WEBGL);
     *
     *   describe('A white cube on a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Enable orbiting with the mouse.
     *   orbitControl();
     *
     *   // Rotate the coordinate system 1/8 turn.
     *   rotateY(QUARTER_PI);
     *
     *   // Draw a box.
     *   box();
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * // Click and drag the mouse to view the scene from different angles.
     *
     * function setup() {
     *   createCanvas(100, 100, WEBGL);
     *
     *   describe('A white cube on a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Enable orbiting with the mouse.
     *   orbitControl();
     *
     *   // Rotate the coordinate system 1/16 turn.
     *   rotateY(QUARTER_PI / 2);
     *
     *   // Rotate the coordinate system 1/16 turn.
     *   rotateY(QUARTER_PI / 2);
     *
     *   // Draw a box.
     *   box();
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * // Click and drag the mouse to view the scene from different angles.
     *
     * function setup() {
     *   createCanvas(100, 100, WEBGL);
     *
     *   // Use degrees.
     *   angleMode(DEGREES);
     *
     *   describe('A white cube on a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Enable orbiting with the mouse.
     *   orbitControl();
     *
     *   // Rotate the coordinate system 1/8 turn.
     *   rotateY(45);
     *
     *   // Draw a box.
     *   box();
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * // Click and drag the mouse to view the scene from different angles.
     *
     * function setup() {
     *   createCanvas(100, 100, WEBGL);
     *
     *   describe('A white cube rotates slowly against a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Enable orbiting with the mouse.
     *   orbitControl();
     *
     *   // Rotate the coordinate system a little more each frame.
     *   let angle = frameCount * 0.01;
     *   rotateY(angle);
     *
     *   // Draw a box.
     *   box();
     * }
     * </code>
     * </div>
     */
    fn.rotateY = function(angle) {
      this._assert3d('rotateY');
      // p5._validateParameters('rotateY', arguments);
      this._renderer.rotateY(this._toRadians(angle));
      return this;
    };

    /**
     * Rotates the coordinate system about the z-axis in WebGL mode.
     *
     * The parameter, `angle`, is the amount to rotate. For example, calling
     * `rotateZ(1)` rotates the coordinate system about the z-axis by 1 radian.
     * `rotateZ()` interprets angle values using the current
     * <a href="#/p5/angleMode">angleMode()</a>.
     *
     * By default, transformations accumulate. For example, calling `rotateZ(1)`
     * twice has the same effect as calling `rotateZ(2)` once. The
     * <a href="#/p5/push">push()</a> and <a href="#/p5/pop">pop()</a> functions
     * can be used to isolate transformations within distinct drawing groups.
     *
     * Note: Transformations are reset at the beginning of the draw loop. Calling
     * `rotateZ(1)` inside the <a href="#/p5/draw">draw()</a> function won't cause
     * shapes to spin.
     *
     * @method rotateZ
     * @param  {Number} angle angle of rotation in the current <a href="#/p5/angleMode">angleMode()</a>.
     * @chainable
     *
     * @example
     * <div>
     * <code>
     * // Click and drag the mouse to view the scene from different angles.
     *
     * function setup() {
     *   createCanvas(100, 100, WEBGL);
     *
     *   describe('A white cube on a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Enable orbiting with the mouse.
     *   orbitControl();
     *
     *   // Rotate the coordinate system 1/8 turn.
     *   rotateZ(QUARTER_PI);
     *
     *   // Draw a box.
     *   box();
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * // Click and drag the mouse to view the scene from different angles.
     *
     * function setup() {
     *   createCanvas(100, 100, WEBGL);
     *
     *   describe('A white cube on a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Enable orbiting with the mouse.
     *   orbitControl();
     *
     *   // Rotate the coordinate system 1/16 turn.
     *   rotateZ(QUARTER_PI / 2);
     *
     *   // Rotate the coordinate system 1/16 turn.
     *   rotateZ(QUARTER_PI / 2);
     *
     *   // Draw a box.
     *   box();
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * // Click and drag the mouse to view the scene from different angles.
     *
     * function setup() {
     *   createCanvas(100, 100, WEBGL);
     *
     *   // Use degrees.
     *   angleMode(DEGREES);
     *
     *   describe('A white cube on a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Enable orbiting with the mouse.
     *   orbitControl();
     *
     *   // Rotate the coordinate system 1/8 turn.
     *   rotateZ(45);
     *
     *   // Draw a box.
     *   box();
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * // Click and drag the mouse to view the scene from different angles.
     *
     * function setup() {
     *   createCanvas(100, 100, WEBGL);
     *
     *   describe('A white cube rotates slowly against a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Enable orbiting with the mouse.
     *   orbitControl();
     *
     *   // Rotate the coordinate system a little more each frame.
     *   let angle = frameCount * 0.01;
     *   rotateZ(angle);
     *
     *   // Draw a box.
     *   box();
     * }
     * </code>
     * </div>
     */
    fn.rotateZ = function(angle) {
      this._assert3d('rotateZ');
      // p5._validateParameters('rotateZ', arguments);
      this._renderer.rotateZ(this._toRadians(angle));
      return this;
    };

    /**
     * Scales the coordinate system.
     *
     * By default, shapes are drawn at their original scale. A rectangle that's 50
     * pixels wide appears to take up half the width of a 100 pixel-wide canvas.
     * The `scale()` function can shrink or stretch the coordinate system so that
     * shapes appear at different sizes. There are two ways to call `scale()` with
     * parameters that set the scale factor(s).
     *
     * The first way to call `scale()` uses numbers to set the amount of scaling.
     * The first parameter, `s`, sets the amount to scale each axis. For example,
     * calling `scale(2)` stretches the x-, y-, and z-axes by a factor of 2. The
     * next two parameters, `y` and `z`, are optional. They set the amount to
     * scale the y- and z-axes. For example, calling `scale(2, 0.5, 1)` stretches
     * the x-axis by a factor of 2, shrinks the y-axis by a factor of 0.5, and
     * leaves the z-axis unchanged.
     *
     * The second way to call `scale()` uses a <a href="#/p5.Vector">p5.Vector</a>
     * object to set the scale factors. For example, calling `scale(myVector)`
     * uses the x-, y-, and z-components of `myVector` to set the amount of
     * scaling along the x-, y-, and z-axes. Doing so is the same as calling
     * `scale(myVector.x, myVector.y, myVector.z)`.
     *
     * By default, transformations accumulate. For example, calling `scale(1)`
     * twice has the same effect as calling `scale(2)` once. The
     * <a href="#/p5/push">push()</a> and <a href="#/p5/pop">pop()</a> functions
     * can be used to isolate transformations within distinct drawing groups.
     *
     * Note: Transformations are reset at the beginning of the draw loop. Calling
     * `scale(2)` inside the <a href="#/p5/draw">draw()</a> function won't cause
     * shapes to grow continuously.
     *
     * @method scale
     * @param  {Number|p5.Vector|Number[]} s amount to scale along the positive x-axis.
     * @param  {Number} [y] amount to scale along the positive y-axis. Defaults to `s`.
     * @param  {Number} [z] amount to scale along the positive z-axis. Defaults to `y`.
     * @chainable
     *
     * @example
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   describe(
     *     'Two white squares on a gray background. The larger square appears at the top-center. The smaller square appears at the top-left.'
     *   );
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Draw a square at (30, 20).
     *   square(30, 20, 40);
     *
     *   // Scale the coordinate system by a factor of 0.5.
     *   scale(0.5);
     *
     *   // Draw a square at (30, 20).
     *   // It appears at (15, 10) after scaling.
     *   square(30, 20, 40);
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   describe('A rectangle and a square drawn in white on a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Draw a square at (30, 20).
     *   square(30, 20, 40);
     *
     *   // Scale the coordinate system by factors of
     *   // 0.5 along the x-axis and
     *   // 1.3 along the y-axis.
     *   scale(0.5, 1.3);
     *
     *   // Draw a square at (30, 20).
     *   // It appears as a rectangle at (15, 26) after scaling.
     *   square(30, 20, 40);
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   describe('A rectangle and a square drawn in white on a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Draw a square at (30, 20).
     *   square(30, 20, 40);
     *
     *   // Create a p5.Vector object.
     *   let v = createVector(0.5, 1.3);
     *
     *   // Scale the coordinate system by factors of
     *   // 0.5 along the x-axis and
     *   // 1.3 along the y-axis.
     *   scale(v);
     *
     *   // Draw a square at (30, 20).
     *   // It appears as a rectangle at (15, 26) after scaling.
     *   square(30, 20, 40);
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * // Click and drag the mouse to view the scene from different angles.
     *
     * function setup() {
     *   createCanvas(100, 100, WEBGL);
     *
     *   describe(
     *     'A red box and a blue box drawn on a gray background. The red box appears embedded in the blue box.'
     *   );
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Enable orbiting with the mouse.
     *   orbitControl();
     *
     *   // Turn on the lights.
     *   lights();
     *
     *   // Style the spheres.
     *   noStroke();
     *
     *   // Draw the red sphere.
     *   fill('red');
     *   box();
     *
     *   // Scale the coordinate system by factors of
     *   // 0.5 along the x-axis and
     *   // 1.3 along the y-axis and
     *   // 2 along the z-axis.
     *   scale(0.5, 1.3, 2);
     *
     *   // Draw the blue sphere.
     *   fill('blue');
     *   box();
     * }
     * </code>
     * </div>
     */
    /**
     * @method scale
     * @param  {p5.Vector|Number[]} scales vector whose components should be used to scale.
     * @chainable
     */
    fn.scale = function(x, y, z) {
      // p5._validateParameters('scale', arguments);
      // Only check for Vector argument type if Vector is available
      if (x instanceof p5.Vector) {
        const v = x;
        x = v.x;
        y = v.y;
        z = v.z;
      } else if (Array.isArray(x)) {
        const rg = x;
        x = rg[0];
        y = rg[1];
        z = rg[2] || 1;
      }
      if (isNaN(y)) {
        y = z = x;
      } else if (isNaN(z)) {
        z = 1;
      }

      this._renderer.scale(x, y, z);

      return this;
    };

    /**
     * Shears the x-axis so that shapes appear skewed.
     *
     * By default, the x- and y-axes are perpendicular. The `shearX()` function
     * transforms the coordinate system so that x-coordinates are translated while
     * y-coordinates are fixed.
     *
     * The first parameter, `angle`, is the amount to shear. For example, calling
     * `shearX(1)` transforms all x-coordinates using the formula
     * `x = x + y * tan(angle)`. `shearX()` interprets angle values using the
     * current <a href="#/p5/angleMode">angleMode()</a>.
     *
     * By default, transformations accumulate. For example, calling
     * `shearX(1)` twice has the same effect as calling `shearX(2)` once. The
     * <a href="#/p5/push">push()</a> and
     * <a href="#/p5/pop">pop()</a> functions can be used to isolate
     * transformations within distinct drawing groups.
     *
     * Note: Transformations are reset at the beginning of the draw loop. Calling
     * `shearX(1)` inside the <a href="#/p5/draw">draw()</a> function won't
     * cause shapes to shear continuously.
     *
     * @method shearX
     * @param  {Number} angle angle to shear by in the current <a href="#/p5/angleMode">angleMode()</a>.
     * @chainable
     *
     * @example
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   describe('A white quadrilateral on a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Shear the coordinate system along the x-axis.
     *   shearX(QUARTER_PI);
     *
     *   // Draw the square.
     *   square(0, 0, 50);
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   // Use degrees.
     *   angleMode(DEGREES);
     *
     *   describe('A white quadrilateral on a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Shear the coordinate system along the x-axis.
     *   shearX(45);
     *
     *   // Draw the square.
     *   square(0, 0, 50);
     * }
     * </code>
     * </div>
     */
    fn.shearX = function(angle) {
      // p5._validateParameters('shearX', arguments);
      const rad = this._toRadians(angle);
      this._renderer.applyMatrix(1, 0, Math.tan(rad), 1, 0, 0);
      return this;
    };

    /**
     * Shears the y-axis so that shapes appear skewed.
     *
     * By default, the x- and y-axes are perpendicular. The `shearY()` function
     * transforms the coordinate system so that y-coordinates are translated while
     * x-coordinates are fixed.
     *
     * The first parameter, `angle`, is the amount to shear. For example, calling
     * `shearY(1)` transforms all y-coordinates using the formula
     * `y = y + x * tan(angle)`. `shearY()` interprets angle values using the
     * current <a href="#/p5/angleMode">angleMode()</a>.
     *
     * By default, transformations accumulate. For example, calling
     * `shearY(1)` twice has the same effect as calling `shearY(2)` once. The
     * <a href="#/p5/push">push()</a> and
     * <a href="#/p5/pop">pop()</a> functions can be used to isolate
     * transformations within distinct drawing groups.
     *
     * Note: Transformations are reset at the beginning of the draw loop. Calling
     * `shearY(1)` inside the <a href="#/p5/draw">draw()</a> function won't
     * cause shapes to shear continuously.
     *
     * @method shearY
     * @param  {Number} angle angle to shear by in the current <a href="#/p5/angleMode">angleMode()</a>.
     * @chainable
     *
     * @example
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   describe('A white quadrilateral on a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Shear the coordinate system along the x-axis.
     *   shearY(QUARTER_PI);
     *
     *   // Draw the square.
     *   square(0, 0, 50);
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   // Use degrees.
     *   angleMode(DEGREES);
     *
     *   describe('A white quadrilateral on a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Shear the coordinate system along the x-axis.
     *   shearY(45);
     *
     *   // Draw the square.
     *   square(0, 0, 50);
     * }
     * </code>
     * </div>
     */
    fn.shearY = function(angle) {
      // p5._validateParameters('shearY', arguments);
      const rad = this._toRadians(angle);
      this._renderer.applyMatrix(1, Math.tan(rad), 0, 1, 0, 0);
      return this;
    };

    /**
     * Translates the coordinate system.
     *
     * By default, the origin `(0, 0)` is at the sketch's top-left corner in 2D
     * mode and center in WebGL mode. The `translate()` function shifts the origin
     * to a different position. Everything drawn after `translate()` is called
     * will appear to be shifted. There are two ways to call `translate()` with
     * parameters that set the origin's position.
     *
     * The first way to call `translate()` uses numbers to set the amount of
     * translation. The first two parameters, `x` and `y`, set the amount to
     * translate along the positive x- and y-axes. For example, calling
     * `translate(20, 30)` translates the origin 20 pixels along the x-axis and 30
     * pixels along the y-axis. The third parameter, `z`, is optional. It sets the
     * amount to translate along the positive z-axis. For example, calling
     * `translate(20, 30, 40)` translates the origin 20 pixels along the x-axis,
     * 30 pixels along the y-axis, and 40 pixels along the z-axis.
     *
     * The second way to call `translate()` uses a
     * <a href="#/p5.Vector">p5.Vector</a> object to set the amount of
     * translation. For example, calling `translate(myVector)` uses the x-, y-,
     * and z-components of `myVector` to set the amount to translate along the x-,
     * y-, and z-axes. Doing so is the same as calling
     * `translate(myVector.x, myVector.y, myVector.z)`.
     *
     * By default, transformations accumulate. For example, calling
     * `translate(10, 0)` twice has the same effect as calling
     * `translate(20, 0)` once. The <a href="#/p5/push">push()</a> and
     * <a href="#/p5/pop">pop()</a> functions can be used to isolate
     * transformations within distinct drawing groups.
     *
     * Note: Transformations are reset at the beginning of the draw loop. Calling
     * `translate(10, 0)` inside the <a href="#/p5/draw">draw()</a> function won't
     * cause shapes to move continuously.
     *
     * @method translate
     * @param  {Number} x amount to translate along the positive x-axis.
     * @param  {Number} y amount to translate along the positive y-axis.
     * @param  {Number} [z] amount to translate along the positive z-axis.
     * @chainable
     *
     * @example
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   describe('A white circle on a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Translate the origin to the center.
     *   translate(50, 50);
     *
     *   // Draw a circle at coordinates (0, 0).
     *   circle(0, 0, 40);
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   describe(
     *     'Two circles drawn on a gray background. The blue circle on the right overlaps the red circle at the center.'
     *   );
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Translate the origin to the center.
     *   translate(50, 50);
     *
     *   // Draw the red circle.
     *   fill('red');
     *   circle(0, 0, 40);
     *
     *   // Translate the origin to the right.
     *   translate(25, 0);
     *
     *   // Draw the blue circle.
     *   fill('blue');
     *   circle(0, 0, 40);
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   describe('A white circle moves slowly from left to right on a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Calculate the x-coordinate.
     *   let x = frameCount * 0.2;
     *
     *   // Translate the origin.
     *   translate(x, 50);
     *
     *   // Draw a circle at coordinates (0, 0).
     *   circle(0, 0, 40);
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   describe('A white circle on a gray background.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Create a p5.Vector object.
     *   let v = createVector(50, 50);
     *
     *   // Translate the origin by the vector.
     *   translate(v);
     *
     *   // Draw a circle at coordinates (0, 0).
     *   circle(0, 0, 40);
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100, WEBGL);
     *
     *   describe(
     *     'Two spheres sitting side-by-side on gray background. The sphere at the center is red. The sphere on the right is blue.'
     *   );
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Turn on the lights.
     *   lights();
     *
     *   // Style the spheres.
     *   noStroke();
     *
     *   // Draw the red sphere.
     *   fill('red');
     *   sphere(10);
     *
     *   // Translate the origin to the right.
     *   translate(30, 0, 0);
     *
     *   // Draw the blue sphere.
     *   fill('blue');
     *   sphere(10);
     * }
     * </code>
     * </div>
     */
    /**
     * @method translate
     * @param  {p5.Vector} vector vector by which to translate.
     * @chainable
     */
    fn.translate = function(x, y, z) {
      // p5._validateParameters('translate', arguments);
      if (this._renderer.isP3D) {
        this._renderer.translate(x, y, z);
      } else {
        this._renderer.translate(x, y);
      }
      return this;
    };

    /**
     * Begins a drawing group that contains its own styles and transformations.
     *
     * By default, styles such as <a href="#/p5/fill">fill()</a> and
     * transformations such as <a href="#/p5/rotate">rotate()</a> are applied to
     * all drawing that follows. The `push()` and <a href="#/p5/pop">pop()</a>
     * functions can limit the effect of styles and transformations to a specific
     * group of shapes, images, and text. For example, a group of shapes could be
     * translated to follow the mouse without affecting the rest of the sketch:
     *
     * ```js
     * // Begin the drawing group.
     * push();
     *
     * // Translate the origin to the mouse's position.
     * translate(mouseX, mouseY);
     *
     * // Style the face.
     * noStroke();
     * fill('green');
     *
     * // Draw the face.
     * circle(0, 0, 60);
     *
     * // Style the eyes.
     * fill('white');
     *
     * // Draw the left eye.
     * ellipse(-20, -20, 30, 20);
     *
     * // Draw the right eye.
     * ellipse(20, -20, 30, 20);
     *
     * // End the drawing group.
     * pop();
     *
     * // Draw a bug.
     * let x = random(0, 100);
     * let y = random(0, 100);
     * text('🦟', x, y);
     * ```
     *
     * In the code snippet above, the bug's position isn't affected by
     * `translate(mouseX, mouseY)` because that transformation is contained
     * between `push()` and <a href="#/p5/pop">pop()</a>. The bug moves around
     * the entire canvas as expected.
     *
     * Note: `push()` and <a href="#/p5/pop">pop()</a> are always called as a
     * pair. Both functions are required to begin and end a drawing group.
     *
     * `push()` and <a href="#/p5/pop">pop()</a> can also be nested to create
     * subgroups. For example, the code snippet above could be changed to give
     * more detail to the frog’s eyes:
     *
     * ```js
     * // Begin the drawing group.
     * push();
     *
     * // Translate the origin to the mouse's position.
     * translate(mouseX, mouseY);
     *
     * // Style the face.
     * noStroke();
     * fill('green');
     *
     * // Draw a face.
     * circle(0, 0, 60);
     *
     * // Style the eyes.
     * fill('white');
     *
     * // Draw the left eye.
     * push();
     * translate(-20, -20);
     * ellipse(0, 0, 30, 20);
     * fill('black');
     * circle(0, 0, 8);
     * pop();
     *
     * // Draw the right eye.
     * push();
     * translate(20, -20);
     * ellipse(0, 0, 30, 20);
     * fill('black');
     * circle(0, 0, 8);
     * pop();
     *
     * // End the drawing group.
     * pop();
     *
     * // Draw a bug.
     * let x = random(0, 100);
     * let y = random(0, 100);
     * text('🦟', x, y);
     * ```
     *
     * In this version, the code to draw each eye is contained between its own
     * `push()` and <a href="#/p5/pop">pop()</a> functions. Doing so makes it
     * easier to add details in the correct part of a drawing.
     *
     * `push()` and <a href="#/p5/pop">pop()</a> contain the effects of the
     * following functions:
     *
     * - <a href="#/p5/fill">fill()</a>
     * - <a href="#/p5/noFill">noFill()</a>
     * - <a href="#/p5/noStroke">noStroke()</a>
     * - <a href="#/p5/stroke">stroke()</a>
     * - <a href="#/p5/tint">tint()</a>
     * - <a href="#/p5/noTint">noTint()</a>
     * - <a href="#/p5/strokeWeight">strokeWeight()</a>
     * - <a href="#/p5/strokeCap">strokeCap()</a>
     * - <a href="#/p5/strokeJoin">strokeJoin()</a>
     * - <a href="#/p5/imageMode">imageMode()</a>
     * - <a href="#/p5/rectMode">rectMode()</a>
     * - <a href="#/p5/ellipseMode">ellipseMode()</a>
     * - <a href="#/p5/colorMode">colorMode()</a>
     * - <a href="#/p5/textAlign">textAlign()</a>
     * - <a href="#/p5/textFont">textFont()</a>
     * - <a href="#/p5/textSize">textSize()</a>
     * - <a href="#/p5/textLeading">textLeading()</a>
     * - <a href="#/p5/applyMatrix">applyMatrix()</a>
     * - <a href="#/p5/resetMatrix">resetMatrix()</a>
     * - <a href="#/p5/rotate">rotate()</a>
     * - <a href="#/p5/scale">scale()</a>
     * - <a href="#/p5/shearX">shearX()</a>
     * - <a href="#/p5/shearY">shearY()</a>
     * - <a href="#/p5/translate">translate()</a>
     *
     * In WebGL mode, `push()` and <a href="#/p5/pop">pop()</a> contain the
     * effects of a few additional styles:
     *
     * - <a href="#/p5/setCamera">setCamera()</a>
     * - <a href="#/p5/ambientLight">ambientLight()</a>
     * - <a href="#/p5/directionalLight">directionalLight()</a>
     * - <a href="#/p5/pointLight">pointLight()</a> <a href="#/p5/texture">texture()</a>
     * - <a href="#/p5/specularMaterial">specularMaterial()</a>
     * - <a href="#/p5/shininess">shininess()</a>
     * - <a href="#/p5/normalMaterial">normalMaterial()</a>
     * - <a href="#/p5/shader">shader()</a>
     *
     * @method push
     *
     * @example
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   background(200);
     *
     *   // Draw the left circle.
     *   circle(25, 50, 20);
     *
     *   // Begin the drawing group.
     *   push();
     *
     *   // Translate the origin to the center.
     *   translate(50, 50);
     *
     *   // Style the circle.
     *   strokeWeight(5);
     *   stroke('royalblue');
     *   fill('orange');
     *
     *   // Draw the circle.
     *   circle(0, 0, 20);
     *
     *   // End the drawing group.
     *   pop();
     *
     *   // Draw the right circle.
     *   circle(75, 50, 20);
     *
     *   describe(
     *     'Three circles drawn in a row on a gray background. The left and right circles are white with thin, black borders. The middle circle is orange with a thick, blue border.'
     *   );
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   // Slow the frame rate.
     *   frameRate(24);
     *
     *   describe('A mosquito buzzes in front of a green frog. The frog follows the mouse as the user moves.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Begin the drawing group.
     *   push();
     *
     *   // Translate the origin to the mouse's position.
     *   translate(mouseX, mouseY);
     *
     *   // Style the face.
     *   noStroke();
     *   fill('green');
     *
     *   // Draw a face.
     *   circle(0, 0, 60);
     *
     *   // Style the eyes.
     *   fill('white');
     *
     *   // Draw the left eye.
     *   push();
     *   translate(-20, -20);
     *   ellipse(0, 0, 30, 20);
     *   fill('black');
     *   circle(0, 0, 8);
     *   pop();
     *
     *   // Draw the right eye.
     *   push();
     *   translate(20, -20);
     *   ellipse(0, 0, 30, 20);
     *   fill('black');
     *   circle(0, 0, 8);
     *   pop();
     *
     *   // End the drawing group.
     *   pop();
     *
     *   // Draw a bug.
     *   let x = random(0, 100);
     *   let y = random(0, 100);
     *   text('🦟', x, y);
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * // Click and drag the mouse to view the scene from different angles.
     *
     * function setup() {
     *   createCanvas(100, 100, WEBGL);
     *
     *   describe(
     *     'Two spheres drawn on a gray background. The sphere on the left is red and lit from the front. The sphere on the right is a blue wireframe.'
     *   );
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Enable orbiting with the mouse.
     *   orbitControl();
     *
     *   // Draw the red sphere.
     *   push();
     *   translate(-25, 0, 0);
     *   noStroke();
     *   directionalLight(255, 0, 0, 0, 0, -1);
     *   sphere(20);
     *   pop();
     *
     *   // Draw the blue sphere.
     *   push();
     *   translate(25, 0, 0);
     *   strokeWeight(0.3);
     *   stroke(0, 0, 255);
     *   noFill();
     *   sphere(20);
     *   pop();
     * }
     * </code>
     * </div>
     */
    fn.push = function() {
      this._renderer.push();
    };

    /**
     * Ends a drawing group that contains its own styles and transformations.
     *
     * By default, styles such as <a href="#/p5/fill">fill()</a> and
     * transformations such as <a href="#/p5/rotate">rotate()</a> are applied to
     * all drawing that follows. The <a href="#/p5/push">push()</a> and `pop()`
     * functions can limit the effect of styles and transformations to a specific
     * group of shapes, images, and text. For example, a group of shapes could be
     * translated to follow the mouse without affecting the rest of the sketch:
     *
     * ```js
     * // Begin the drawing group.
     * push();
     *
     * // Translate the origin to the mouse's position.
     * translate(mouseX, mouseY);
     *
     * // Style the face.
     * noStroke();
     * fill('green');
     *
     * // Draw the face.
     * circle(0, 0, 60);
     *
     * // Style the eyes.
     * fill('white');
     *
     * // Draw the left eye.
     * ellipse(-20, -20, 30, 20);
     *
     * // Draw the right eye.
     * ellipse(20, -20, 30, 20);
     *
     * // End the drawing group.
     * pop();
     *
     * // Draw a bug.
     * let x = random(0, 100);
     * let y = random(0, 100);
     * text('🦟', x, y);
     * ```
     *
     * In the code snippet above, the bug's position isn't affected by
     * `translate(mouseX, mouseY)` because that transformation is contained
     * between <a href="#/p5/push">push()</a> and `pop()`. The bug moves around
     * the entire canvas as expected.
     *
     * Note: <a href="#/p5/push">push()</a> and `pop()` are always called as a
     * pair. Both functions are required to begin and end a drawing group.
     *
     * <a href="#/p5/push">push()</a> and `pop()` can also be nested to create
     * subgroups. For example, the code snippet above could be changed to give
     * more detail to the frog’s eyes:
     *
     * ```js
     * // Begin the drawing group.
     * push();
     *
     * // Translate the origin to the mouse's position.
     * translate(mouseX, mouseY);
     *
     * // Style the face.
     * noStroke();
     * fill('green');
     *
     * // Draw a face.
     * circle(0, 0, 60);
     *
     * // Style the eyes.
     * fill('white');
     *
     * // Draw the left eye.
     * push();
     * translate(-20, -20);
     * ellipse(0, 0, 30, 20);
     * fill('black');
     * circle(0, 0, 8);
     * pop();
     *
     * // Draw the right eye.
     * push();
     * translate(20, -20);
     * ellipse(0, 0, 30, 20);
     * fill('black');
     * circle(0, 0, 8);
     * pop();
     *
     * // End the drawing group.
     * pop();
     *
     * // Draw a bug.
     * let x = random(0, 100);
     * let y = random(0, 100);
     * text('🦟', x, y);
     * ```
     *
     * In this version, the code to draw each eye is contained between its own
     * <a href="#/p5/push">push()</a> and `pop()` functions. Doing so makes it
     * easier to add details in the correct part of a drawing.
     *
     * <a href="#/p5/push">push()</a> and `pop()` contain the effects of the
     * following functions:
     *
     * - <a href="#/p5/fill">fill()</a>
     * - <a href="#/p5/noFill">noFill()</a>
     * - <a href="#/p5/noStroke">noStroke()</a>
     * - <a href="#/p5/stroke">stroke()</a>
     * - <a href="#/p5/tint">tint()</a>
     * - <a href="#/p5/noTint">noTint()</a>
     * - <a href="#/p5/strokeWeight">strokeWeight()</a>
     * - <a href="#/p5/strokeCap">strokeCap()</a>
     * - <a href="#/p5/strokeJoin">strokeJoin()</a>
     * - <a href="#/p5/imageMode">imageMode()</a>
     * - <a href="#/p5/rectMode">rectMode()</a>
     * - <a href="#/p5/ellipseMode">ellipseMode()</a>
     * - <a href="#/p5/colorMode">colorMode()</a>
     * - <a href="#/p5/textAlign">textAlign()</a>
     * - <a href="#/p5/textFont">textFont()</a>
     * - <a href="#/p5/textSize">textSize()</a>
     * - <a href="#/p5/textLeading">textLeading()</a>
     * - <a href="#/p5/applyMatrix">applyMatrix()</a>
     * - <a href="#/p5/resetMatrix">resetMatrix()</a>
     * - <a href="#/p5/rotate">rotate()</a>
     * - <a href="#/p5/scale">scale()</a>
     * - <a href="#/p5/shearX">shearX()</a>
     * - <a href="#/p5/shearY">shearY()</a>
     * - <a href="#/p5/translate">translate()</a>
     *
     * In WebGL mode, <a href="#/p5/push">push()</a> and `pop()` contain the
     * effects of a few additional styles:
     *
     * - <a href="#/p5/setCamera">setCamera()</a>
     * - <a href="#/p5/ambientLight">ambientLight()</a>
     * - <a href="#/p5/directionalLight">directionalLight()</a>
     * - <a href="#/p5/pointLight">pointLight()</a> <a href="#/p5/texture">texture()</a>
     * - <a href="#/p5/specularMaterial">specularMaterial()</a>
     * - <a href="#/p5/shininess">shininess()</a>
     * - <a href="#/p5/normalMaterial">normalMaterial()</a>
     * - <a href="#/p5/shader">shader()</a>
     *
     * @method pop
     *
     * @example
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   background(200);
     *
     *   // Draw the left circle.
     *   circle(25, 50, 20);
     *
     *   // Begin the drawing group.
     *   push();
     *
     *   // Translate the origin to the center.
     *   translate(50, 50);
     *
     *   // Style the circle.
     *   strokeWeight(5);
     *   stroke('royalblue');
     *   fill('orange');
     *
     *   // Draw the circle.
     *   circle(0, 0, 20);
     *
     *   // End the drawing group.
     *   pop();
     *
     *   // Draw the right circle.
     *   circle(75, 50, 20);
     *
     *   describe(
     *     'Three circles drawn in a row on a gray background. The left and right circles are white with thin, black borders. The middle circle is orange with a thick, blue border.'
     *   );
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   // Slow the frame rate.
     *   frameRate(24);
     *
     *   describe('A mosquito buzzes in front of a green frog. The frog follows the mouse as the user moves.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Begin the drawing group.
     *   push();
     *
     *   // Translate the origin to the mouse's position.
     *   translate(mouseX, mouseY);
     *
     *   // Style the face.
     *   noStroke();
     *   fill('green');
     *
     *   // Draw a face.
     *   circle(0, 0, 60);
     *
     *   // Style the eyes.
     *   fill('white');
     *
     *   // Draw the left eye.
     *   push();
     *   translate(-20, -20);
     *   ellipse(0, 0, 30, 20);
     *   fill('black');
     *   circle(0, 0, 8);
     *   pop();
     *
     *   // Draw the right eye.
     *   push();
     *   translate(20, -20);
     *   ellipse(0, 0, 30, 20);
     *   fill('black');
     *   circle(0, 0, 8);
     *   pop();
     *
     *   // End the drawing group.
     *   pop();
     *
     *   // Draw a bug.
     *   let x = random(0, 100);
     *   let y = random(0, 100);
     *   text('🦟', x, y);
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * // Click and drag the mouse to view the scene from different angles.
     *
     * function setup() {
     *   createCanvas(100, 100, WEBGL);
     *
     *   describe(
     *     'Two spheres drawn on a gray background. The sphere on the left is red and lit from the front. The sphere on the right is a blue wireframe.'
     *   );
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Enable orbiting with the mouse.
     *   orbitControl();
     *
     *   // Draw the red sphere.
     *   push();
     *   translate(-25, 0, 0);
     *   noStroke();
     *   directionalLight(255, 0, 0, 0, 0, -1);
     *   sphere(20);
     *   pop();
     *
     *   // Draw the blue sphere.
     *   push();
     *   translate(25, 0, 0);
     *   strokeWeight(0.3);
     *   stroke(0, 0, 255);
     *   noFill();
     *   sphere(20);
     *   pop();
     * }
     * </code>
     * </div>
     */
    fn.pop = function() {
      this._renderer.pop();
    };
  }

  if(typeof p5 !== 'undefined'){
    transform$1(p5, p5.prototype);
  }

  /**
   * @module Structure
   * @submodule Structure
   * @for p5
   * @requires core
   */

  function structure(p5, fn){
    /**
     * Stops the code in <a href="#/p5/draw">draw()</a> from running repeatedly.
     *
     * By default, <a href="#/p5/draw">draw()</a> tries to run 60 times per
     * second. Calling `noLoop()` stops <a href="#/p5/draw">draw()</a> from
     * repeating. The draw loop can be restarted by calling
     * <a href="#/p5/loop">loop()</a>. <a href="#/p5/draw">draw()</a> can be run
     * once by calling <a href="#/p5/redraw">redraw()</a>.
     *
     * The <a href="#/p5/isLooping">isLooping()</a> function can be used to check
     * whether a sketch is looping, as in `isLooping() === true`.
     *
     * @method noLoop
     *
     * @example
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   // Turn off the draw loop.
     *   noLoop();
     *
     *   describe('A white half-circle on the left edge of a gray square.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Calculate the circle's x-coordinate.
     *   let x = frameCount;
     *
     *   // Draw the circle.
     *   // Normally, the circle would move from left to right.
     *   circle(x, 50, 20);
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * // Double-click to stop the draw loop.
     *
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   // Slow the frame rate.
     *   frameRate(5);
     *
     *   describe('A white circle moves randomly on a gray background. It stops moving when the user double-clicks.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Calculate the circle's coordinates.
     *   let x = random(0, 100);
     *   let y = random(0, 100);
     *
     *   // Draw the circle.
     *   // Normally, the circle would move from left to right.
     *   circle(x, y, 20);
     * }
     *
     * // Stop the draw loop when the user double-clicks.
     * function doubleClicked() {
     *   noLoop();
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * let startButton;
     * let stopButton;
     *
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   // Create the button elements and place them
     *   // beneath the canvas.
     *   startButton = createButton('▶');
     *   startButton.position(0, 100);
     *   startButton.size(50, 20);
     *   stopButton = createButton('◾');
     *   stopButton.position(50, 100);
     *   stopButton.size(50, 20);
     *
     *   // Set functions to call when the buttons are pressed.
     *   startButton.mousePressed(loop);
     *   stopButton.mousePressed(noLoop);
     *
     *   // Slow the frame rate.
     *   frameRate(5);
     *
     *   describe(
     *     'A white circle moves randomly on a gray background. Play and stop buttons are shown beneath the canvas. The circle stops or starts moving when the user presses a button.'
     *   );
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Calculate the circle's coordinates.
     *   let x = random(0, 100);
     *   let y = random(0, 100);
     *
     *   // Draw the circle.
     *   // Normally, the circle would move from left to right.
     *   circle(x, y, 20);
     * }
     * </code>
     * </div>
     */
    fn.noLoop = function() {
      this._loop = false;
    };

    /**
     * Resumes the draw loop after <a href="#/p5/noLoop">noLoop()</a> has been
     * called.
     *
     * By default, <a href="#/p5/draw">draw()</a> tries to run 60 times per
     * second. Calling <a href="#/p5/noLoop">noLoop()</a> stops
     * <a href="#/p5/draw">draw()</a> from repeating. The draw loop can be
     * restarted by calling `loop()`.
     *
     * The <a href="#/p5/isLooping">isLooping()</a> function can be used to check
     * whether a sketch is looping, as in `isLooping() === true`.
     *
     * @method loop
     *
     * @example
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   // Turn off the draw loop.
     *   noLoop();
     *
     *   describe(
     *     'A white half-circle on the left edge of a gray square. The circle starts moving to the right when the user double-clicks.'
     *   );
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Calculate the circle's x-coordinate.
     *   let x = frameCount;
     *
     *   // Draw the circle.
     *   circle(x, 50, 20);
     * }
     *
     * // Resume the draw loop when the user double-clicks.
     * function doubleClicked() {
     *   loop();
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * let startButton;
     * let stopButton;
     *
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   // Create the button elements and place them
     *   // beneath the canvas.
     *   startButton = createButton('▶');
     *   startButton.position(0, 100);
     *   startButton.size(50, 20);
     *   stopButton = createButton('◾');
     *   stopButton.position(50, 100);
     *   stopButton.size(50, 20);
     *
     *   // Set functions to call when the buttons are pressed.
     *   startButton.mousePressed(loop);
     *   stopButton.mousePressed(noLoop);
     *
     *   // Slow the frame rate.
     *   frameRate(5);
     *
     *   describe(
     *     'A white circle moves randomly on a gray background. Play and stop buttons are shown beneath the canvas. The circle stops or starts moving when the user presses a button.'
     *   );
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Calculate the circle's coordinates.
     *   let x = random(0, 100);
     *   let y = random(0, 100);
     *
     *   // Draw the circle.
     *   // Normally, the circle would move from left to right.
     *   circle(x, y, 20);
     * }
     * </code>
     * </div>
     */
    fn.loop = function() {
      if (!this._loop) {
        this._loop = true;
        if (this._setupDone) {
          this._draw();
        }
      }
    };

    /**
     * Returns `true` if the draw loop is running and `false` if not.
     *
     * By default, <a href="#/p5/draw">draw()</a> tries to run 60 times per
     * second. Calling <a href="#/p5/noLoop">noLoop()</a> stops
     * <a href="#/p5/draw">draw()</a> from repeating. The draw loop can be
     * restarted by calling <a href="#/p5/loop">loop()</a>.
     *
     * The `isLooping()` function can be used to check whether a sketch is
     * looping, as in `isLooping() === true`.
     *
     * @method isLooping
     * @returns {boolean}
     *
     * @example
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   describe('A white circle drawn against a gray background. When the user double-clicks, the circle stops or resumes following the mouse.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Draw the circle at the mouse's position.
     *   circle(mouseX, mouseY, 20);
     * }
     *
     * // Toggle the draw loop when the user double-clicks.
     * function doubleClicked() {
     *   if (isLooping() === true) {
     *     noLoop();
     *   } else {
     *     loop();
     *   }
     * }
     * </code>
     * </div>
     */
    fn.isLooping = function() {
      return this._loop;
    };

    /**
     * Runs the code in <a href="#/p5/draw">draw()</a> once.
     *
     * By default, <a href="#/p5/draw">draw()</a> tries to run 60 times per
     * second. Calling <a href="#/p5/noLoop">noLoop()</a> stops
     * <a href="#/p5/draw">draw()</a> from repeating. Calling `redraw()` will
     * execute the code in the <a href="#/p5/draw">draw()</a> function a set
     * number of times.
     *
     * The parameter, `n`, is optional. If a number is passed, as in `redraw(5)`,
     * then the draw loop will run the given number of times. By default, `n` is
     * 1.
     *
     * @method redraw
     * @param  {Integer} [n] number of times to run <a href="#/p5/draw">draw()</a>. Defaults to 1.
     *
     * @example
     * <div>
     * <code>
     * // Double-click the canvas to move the circle.
     *
     * let x = 0;
     *
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   // Turn off the draw loop.
     *   noLoop();
     *
     *   describe(
     *     'A white half-circle on the left edge of a gray square. The circle moves a little to the right when the user double-clicks.'
     *   );
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Draw the circle.
     *   circle(x, 50, 20);
     *
     *   // Increment x.
     *   x += 5;
     * }
     *
     * // Run the draw loop when the user double-clicks.
     * function doubleClicked() {
     *   redraw();
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * // Double-click the canvas to move the circle.
     *
     * let x = 0;
     *
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   // Turn off the draw loop.
     *   noLoop();
     *
     *   describe(
     *     'A white half-circle on the left edge of a gray square. The circle hops to the right when the user double-clicks.'
     *   );
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   // Draw the circle.
     *   circle(x, 50, 20);
     *
     *   // Increment x.
     *   x += 5;
     * }
     *
     * // Run the draw loop three times when the user double-clicks.
     * function doubleClicked() {
     *   redraw(3);
     * }
     * </code>
     * </div>
     */
    fn.redraw = async function(n) {
      if (this._inUserDraw || !this._setupDone) {
        return;
      }

      let numberOfRedraws = parseInt(n);
      if (isNaN(numberOfRedraws) || numberOfRedraws < 1) {
        numberOfRedraws = 1;
      }

      const context = this._isGlobal ? window : this;
      if (typeof context.draw === 'function') {
        if (typeof context.setup === 'undefined') {
          context.scale(context._pixelDensity, context._pixelDensity);
        }
        for (let idxRedraw = 0; idxRedraw < numberOfRedraws; idxRedraw++) {
          context.resetMatrix();
          if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
            this._updateAccsOutput();
          }
          if (this._renderer.isP3D) {
            this._renderer._update();
          }
          this.frameCount = context.frameCount + 1;
          await this._runLifecycleHook('predraw');
          this._inUserDraw = true;
          try {
            await context.draw();
          } finally {
            this._inUserDraw = false;
          }
          await this._runLifecycleHook('postdraw');
        }
      }
    };

    /**
     * Creates a new sketch in "instance" mode.
     *
     * All p5.js sketches are instances of the `p5` class. Put another way, all
     * p5.js sketches are objects with methods including `pInst.setup()`,
     * `pInst.draw()`, `pInst.circle()`, and `pInst.fill()`. By default, sketches
     * run in "global mode" to hide some of this complexity.
     *
     * In global mode, a default instance of the `p5` class is created
     * automatically. The default `p5` instance searches the web page's source
     * code for declarations of system functions such as `setup()`, `draw()`,
     * and `mousePressed()`, then attaches those functions to itself as methods.
     * Calling a function such as `circle()` in global mode actually calls the
     * default `p5` object's `pInst.circle()` method.
     *
     * It's often helpful to isolate the code within sketches from the rest of the
     * code on a web page. Two common use cases are web pages that use other
     * JavaScript libraries and web pages with multiple sketches. "Instance mode"
     * makes it easy to support both of these scenarios.
     *
     * Instance mode sketches support the same API as global mode sketches. They
     * use a function to bundle, or encapsulate, an entire sketch. The function
     * containing the sketch is then passed to the `p5()` constructor.
     *
     * The first parameter, `sketch`, is a function that contains the sketch. For
     * example, the statement `new p5(mySketch)` would create a new instance mode
     * sketch from a function named `mySketch`. The function should have one
     * parameter, `p`, that's a `p5` object.
     *
     * The second parameter, `node`, is optional. If a string is passed, as in
     * `new p5(mySketch, 'sketch-one')` the new instance mode sketch will become a
     * child of the HTML element with the id `sketch-one`. If an HTML element is
     * passed, as in `new p5(mySketch, myElement)`, then the new instance mode
     * sketch will become a child of the `Element` object called `myElement`.
     *
     * @method p5
     * @param {Object} sketch function containing the sketch.
     * @param {String|HTMLElement} node ID or reference to the HTML element that will contain the sketch.
     *
     * @example
     * <div class='norender notest'>
     * <code>
     * // Declare the function containing the sketch.
     * function sketch(p) {
     *
     *   // Declare the setup() method.
     *   p.setup = function () {
     *     p.createCanvas(100, 100);
     *
     *     p.describe('A white circle drawn on a gray background.');
     *   };
     *
     *   // Declare the draw() method.
     *   p.draw = function () {
     *     p.background(200);
     *
     *     // Draw the circle.
     *     p.circle(50, 50, 20);
     *   };
     * }
     *
     * // Initialize the sketch.
     * new p5(sketch);
     * </code>
     * </div>
     *
     * <div class='norender notest'>
     * <code>
     * // Declare the function containing the sketch.
     * function sketch(p) {
     *   // Create the sketch's variables within its scope.
     *   let x = 50;
     *   let y = 50;
     *
     *   // Declare the setup() method.
     *   p.setup = function () {
     *     p.createCanvas(100, 100);
     *
     *     p.describe('A white circle moves randomly on a gray background.');
     *   };
     *
     *   // Declare the draw() method.
     *   p.draw = function () {
     *     p.background(200);
     *
     *     // Update x and y.
     *     x += p.random(-1, 1);
     *     y += p.random(-1, 1);
     *
     *     // Draw the circle.
     *     p.circle(x, y, 20);
     *   };
     * }
     *
     * // Initialize the sketch.
     * new p5(sketch);
     * </code>
     * </div>
     *
     * <div class='norender notest'>
     * <code>
     * // Declare the function containing the sketch.
     * function sketch(p) {
     *
     *   // Declare the setup() method.
     *   p.setup = function () {
     *     p.createCanvas(100, 100);
     *
     *     p.describe('A white circle drawn on a gray background.');
     *   };
     *
     *   // Declare the draw() method.
     *   p.draw = function () {
     *     p.background(200);
     *
     *     // Draw the circle.
     *     p.circle(50, 50, 20);
     *   };
     * }
     *
     * // Select the web page's body element.
     * let body = document.querySelector('body');
     *
     * // Initialize the sketch and attach it to the web page's body.
     * new p5(sketch, body);
     * </code>
     * </div>
     *
     * <div class='norender notest'>
     * <code>
     * // Declare the function containing the sketch.
     * function sketch(p) {
     *
     *   // Declare the setup() method.
     *   p.setup = function () {
     *     p.createCanvas(100, 100);
     *
     *     p.describe(
     *       'A white circle drawn on a gray background. The circle follows the mouse as the user moves.'
     *     );
     *   };
     *
     *   // Declare the draw() method.
     *   p.draw = function () {
     *     p.background(200);
     *
     *     // Draw the circle.
     *     p.circle(p.mouseX, p.mouseY, 20);
     *   };
     * }
     *
     * // Initialize the sketch.
     * new p5(sketch);
     * </code>
     * </div>
     *
     * <div class='norender notest'>
     * <code>
     * // Declare the function containing the sketch.
     * function sketch(p) {
     *
     *   // Declare the setup() method.
     *   p.setup = function () {
     *     p.createCanvas(100, 100);
     *
     *     p.describe(
     *       'A white circle drawn on a gray background. The circle follows the mouse as the user moves. The circle becomes black when the user double-clicks.'
     *     );
     *   };
     *
     *   // Declare the draw() method.
     *   p.draw = function () {
     *     p.background(200);
     *
     *     // Draw the circle.
     *     p.circle(p.mouseX, p.mouseY, 20);
     *   };
     *
     *   // Declare the doubleClicked() method.
     *   p.doubleClicked = function () {
     *     // Change the fill color when the user double-clicks.
     *     p.fill(0);
     *   };
     * }
     *
     * // Initialize the sketch.
     * new p5(sketch);
     * </code>
     * </div>
     */
  }

  if(typeof p5 !== 'undefined'){
    structure(p5, p5.prototype);
  }

  /**
   * @module Math
   * @requires constants
   */


  /// HELPERS FOR REMAINDER METHOD
  const calculateRemainder2D = function (xComponent, yComponent) {
    if (xComponent !== 0) {
      this.x = this.x % xComponent;
    }
    if (yComponent !== 0) {
      this.y = this.y % yComponent;
    }
    return this;
  };

  const calculateRemainder3D = function (xComponent, yComponent, zComponent) {
    if (xComponent !== 0) {
      this.x = this.x % xComponent;
    }
    if (yComponent !== 0) {
      this.y = this.y % yComponent;
    }
    if (zComponent !== 0) {
      this.z = this.z % zComponent;
    }
    return this;
  };

  class Vector {
    // This is how it comes in with createVector()
    // This check if the first argument is a function
    constructor(...args) {
      let values = args.map((arg) => arg || 0);
      if (typeof args[0] === "function") {
        this.isPInst = true;
        this._fromRadians = args[0];
        this._toRadians = args[1];
        values = args.slice(2).map((arg) => arg || 0);
      }
      let dimensions = values.length; // TODO: make default 3 if no arguments
      if (dimensions === 0) {
        this.dimensions = 2;
        this._values = [0, 0, 0];
      } else {
        this.dimensions = dimensions;
        this._values = values;
      }
    }

    /**
     * Gets the values of the N-dimensional vector.
     *
     * This method returns an array of numbers that represent the vector.
     * Each number in the array corresponds to a different component of the vector,
     * like its position in different directions (e.g., x, y, z).
     *
     * @returns {Array<number>} The array of values representing the vector.
     */
    get values() {
      return this._values;
    }

    /**
     * Sets the values of the vector.
     *
     * This method allows you to update the entire vector with a new set of values.
     * You need to provide an array of numbers, where each number represents a component
     * of the vector (e.g., x, y, z). The length of the array should match the number of
     * dimensions of the vector. If the array is shorter, the missing components will be
     * set to 0. If the array is longer, the extra values will be ignored.
     *
     * @param {Array<number>} newValues - An array of numbers representing the new values for the vector.
     *
     */
    set values(newValues) {
      let dimensions = newValues.length;
      if (dimensions === 0) {
        this.dimensions = 2;
        this._values = [0, 0, 0];
      } else {
        this.dimensions = dimensions;
        this._values = newValues.slice();
      }
    }

    /**
     * Gets the x component of the vector.
     *
     * This method returns the value of the x component of the vector.
     * Think of the x component as the horizontal position or the first number in the vector.
     * If the x component is not defined, it will return 0.
     *
     * @returns {Number} The x component of the vector. Returns 0 if the value is not defined.
     */
    get x() {
      return this._values[0] || 0;
    }

    /**
     * Retrieves the value at the specified index from the vector.
     *
     * This method allows you to get the value of a specific component of the vector
     * by providing its index. Think of the vector as a list of numbers, where each
     * number represents a different direction (like x, y, or z). The index is just
     * the position of the number in that list.
     *
     * For example, if you have a vector with values 10, 20, 30 the index 0 would
     * give you the first value 10, index 1 would give you the second value 20,
     * and so on.
     *
     * @param {Number} index - The position of the value you want to get from the vector.
     * @returns {Number} The value at the specified position in the vector.
     * @throws Will throw an error if the index is out of bounds, meaning if you try to
     *          get a value from a position that doesn't exist in the vector.
     */
    getValue(index) {
      if (index < this._values.length) {
        return this._values[index];
      } else {
        p5._friendlyError(
          "The index parameter is trying to set a value outside the bounds of the vector",
          "p5.Vector.setValue"
        );
      }
    }

    /**
     * Sets the value at the specified index of the vector.
     *
     * This method allows you to change a specific component of the vector by providing its index and the new value you want to set.
     * Think of the vector as a list of numbers, where each number represents a different direction (like x, y, or z).
     * The index is just the position of the number in that list.
     *
     * For example, if you have a vector with values [0, 20, 30], and you want to change the second value (20) to 50,
     * you would use this method with index 1 (since indexes start at 0) and value 50.
     *
     * @param {Number} index - The position in the vector where you want to set the new value.
     * @param {Number} value - The new value you want to set at the specified position.
     * @throws Will throw an error if the index is outside the bounds of the vector, meaning if you try to set a value at a position that doesn't exist in the vector.
     */
    setValue(index, value) {
      if (index < this._values.length) {
        this._values[index] = value;
      } else {
        p5._friendlyError(
          "The index parameter is trying to set a value outside the bounds of the vector",
          "p5.Vector.setValue"
        );
      }
    }

    /**
     * Gets the y component of the vector.
     *
     * This method returns the value of the y component of the vector.
     * Think of the y component as the vertical position or the second number in the vector.
     * If the y component is not defined, it will return 0.
     *
     * @returns {Number} The y component of the vector. Returns 0 if the value is not defined.
     */
    get y() {
      return this._values[1] || 0;
    }

    /**
     * Gets the z component of the vector.
     *
     * This method returns the value of the z component of the vector.
     * Think of the z component as the depth or the third number in the vector.
     * If the z component is not defined, it will return 0.
     *
     * @returns {Number} The z component of the vector. Returns 0 if the value is not defined.
     */
    get z() {
      return this._values[2] || 0;
    }

    /**
     * Gets the w component of the vector.
     *
     * This method returns the value of the w component of the vector.
     * Think of the w component as the fourth number in the vector.
     * If the w component is not defined, it will return 0.
     *
     * @returns {Number} The w component of the vector. Returns 0 if the value is not defined.
     */
    get w() {
      return this._values[3] || 0;
    }

    /**
     * Sets the x component of the vector.
     *
     * This method allows you to change the x value of the vector.
     * The x value is the first number in the vector, representing the horizontal position.
     * By calling this method, you can update the x value to a new number.
     *
     * @param {Number} xVal - The new value for the x component.
     */
    set x(xVal) {
      if (this._values.length > 1) {
        this._values[0] = xVal;
      }
    }

    /**
     * Sets the y component of the vector.
     *
     * This method allows you to change the y value of the vector.
     * The y value is the second number in the vector, representing the vertical position.
     * By calling this method, you can update the y value to a new number.
     *
     * @param {Number} yVal - The new value for the y component.
     */
    set y(yVal) {
      if (this._values.length > 1) {
        this._values[1] = yVal;
      }
    }

    /**
     * Sets the z component of the vector.
     *
     * This method allows you to change the z value of the vector.
     * The z value is the third number in the vector, representing the depth or the third dimension.
     * By calling this method, you can update the z value to a new number.
     *
     * @param {Number} zVal - The new value for the z component.
     */
    set z(zVal) {
      if (this._values.length > 2) {
        this._values[2] = zVal;
      }
    }

    /**
     * Sets the w component of the vector.
     *
     * This method allows you to change the w value of the vector.
     * The w value is the fourth number in the vector, representing the fourth dimension.
     * By calling this method, you can update the w value to a new number.
     *
     * @param {Number} wVal - The new value for the w component.
     */
    set w(wVal) {
      if (this._values.length > 3) {
        this._values[3] = wVal;
      }
    }

    /**
     * Returns a string representation of a vector.
     *
     * Calling `toString()` is useful for printing vectors to the console while
     * debugging.
     *
     * @return {String} string representation of the vector.
     *
     * @example
     * <div class = "norender">
     * <code>
     * function setup() {
     *   let v = createVector(20, 30);
     *
     *   // Prints 'p5.Vector Object : [20, 30, 0]'.
     *   print(v.toString());
     * }
     * </code>
     * </div>
     */
    toString() {
      return `[${this.values.join(", ")}]`;
    }

    /**
     * Sets the vector's `x`, `y`, and `z` components.
     *
     * `set()` can use separate numbers, as in `v.set(1, 2, 3)`, a
     * <a href="#/p5.Vector">p5.Vector</a> object, as in `v.set(v2)`, or an
     * array of numbers, as in `v.set([1, 2, 3])`.
     *
     * If a value isn't provided for a component, it will be set to 0. For
     * example, `v.set(4, 5)` sets `v.x` to 4, `v.y` to 5, and `v.z` to 0.
     * Calling `set()` with no arguments, as in `v.set()`, sets all the vector's
     * components to 0.
     *
     * @param {Number} [x] x component of the vector.
     * @param {Number} [y] y component of the vector.
     * @param {Number} [z] z component of the vector.
     * @chainable
     * @example
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   background(200);
     *
     *   // Style the points.
     *   strokeWeight(5);
     *
     *   // Top left.
     *   let pos = createVector(25, 25);
     *   point(pos);
     *
     *   // Top right.
     *   // set() with numbers.
     *   pos.set(75, 25);
     *   point(pos);
     *
     *   // Bottom right.
     *   // set() with a p5.Vector.
     *   let p2 = createVector(75, 75);
     *   pos.set(p2);
     *   point(pos);
     *
     *   // Bottom left.
     *   // set() with an array.
     *   let arr = [25, 75];
     *   pos.set(arr);
     *   point(pos);
     *
     *   describe('Four black dots arranged in a square on a gray background.');
     * }
     * </code>
     * </div>
     */
    /**
     * @param {p5.Vector|Number[]} value vector to set.
     * @chainable
     */
    set(...args) {
      if (args[0] instanceof Vector) {
        this.values = args[0].values.slice();
      } else if (Array.isArray(args[0])) {
        this.values = args[0].map((arg) => arg || 0);
      } else {
        this.values = args.map((arg) => arg || 0);
      }
      this.dimensions = this.values.length;
      return this;
    }

    /**
     * Returns a copy of the <a href="#/p5.Vector">p5.Vector</a> object.
     *
     * @return {p5.Vector} copy of the <a href="#/p5.Vector">p5.Vector</a> object.
     *
     * @example
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100 ,100);
     *
     *   background(200);
     *
     *   // Create a p5.Vector object.
     *   let pos = createVector(50, 50);
     *
     *   // Make a copy.
     *   let pc = pos.copy();
     *
     *   // Draw the point.
     *   strokeWeight(5);
     *   point(pc);
     *
     *   describe('A black point drawn in the middle of a gray square.');
     * }
     * </code>
     * </div>
     */
    copy() {
      if (this.isPInst) {
        return new Vector(this._fromRadians, this._toRadians, ...this.values);
      } else {
        return new Vector(...this.values);
      }
    }

    /**
     * Adds to a vector's components.
     *
     * `add()` can use separate numbers, as in `v.add(1, 2, 3)`,
     * another <a href="#/p5.Vector">p5.Vector</a> object, as in `v.add(v2)`, or
     * an array of numbers, as in `v.add([1, 2, 3])`.
     *
     * If a value isn't provided for a component, it won't change. For
     * example, `v.add(4, 5)` adds 4 to `v.x`, 5 to `v.y`, and 0 to `v.z`.
     * Calling `add()` with no arguments, as in `v.add()`, has no effect.
     *
     * This method supports N-dimensional vectors.
     *
     * The static version of `add()`, as in `p5.Vector.add(v2, v1)`, returns a new
     * <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
     * originals.
     *
     * @param  {Number|Array} x   x component of the vector to be added or an array of components.
     * @param  {Number} [y] y component of the vector to be added.
     * @param  {Number} [z] z component of the vector to be added.
     * @chainable
     *
     * @example
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   background(200);
     *
     *   // Style the points.
     *   strokeWeight(5);
     *
     *   // Top left.
     *   let pos = createVector(25, 25);
     *   point(pos);
     *
     *   // Top right.
     *   // Add numbers.
     *   pos.add(50, 0);
     *   point(pos);
     *
     *   // Bottom right.
     *   // Add a p5.Vector.
     *   let p2 = createVector(0, 50);
     *   pos.add(p2);
     *   point(pos);
     *
     *   // Bottom left.
     *   // Add an array.
     *   let arr = [-50, 0];
     *   pos.add(arr);
     *   point(pos);
     *
     *   describe('Four black dots arranged in a square on a gray background.');
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   background(200);
     *
     *   // Top left.
     *   let p1 = createVector(25, 25);
     *
     *   // Center.
     *   let p2 = createVector(50, 50);
     *
     *   // Bottom right.
     *   // Add p1 and p2.
     *   let p3 = p5.Vector.add(p1, p2);
     *
     *   // Draw the points.
     *   strokeWeight(5);
     *   point(p1);
     *   point(p2);
     *   point(p3);
     *
     *   describe('Three black dots in a diagonal line from top left to bottom right.');
     * }
     * </code>
     * </div>
     *
     * <div>
     * <code>
     * function setup() {
     *   createCanvas(100, 100);
     *
     *   describe('Three arrows drawn on a gray square. A red arrow extends from the top left corner to the center. A blue arrow extends from the tip of the red arrow. A purple arrow extends from the origin to the tip of the blue arrow.');
     * }
     *
     * function draw() {
     *   background(200);
     *
     *   let origin = createVector(0, 0);
     *
     *   // Draw the red arrow.
     *   let v1 = createVector(50, 50);
     *   drawArrow(origin, v1, 'red');
     *
     *   // Draw the blue arrow.
     *   let v2 = createVector(-30, 20);
     *   drawArrow(v1, v2, 'blue');
     *
     *   // Purple arrow.
     *   let v3 = p5.Vector.add(v1, v2);
     *   drawArrow(origin, v3, 'purple');
     * }
     *
     * // Draws an arrow between two vectors.
     * function drawArrow(base, vec, myColor) {
     *   push();
     *   stroke(myColor);
     *   strokeWeight(3);
     *   fill(myColor);
     *   translate(base.x, base.y);
     *   line(0, 0, vec.x, vec.y);
     *   rotate(vec.heading());
     *   let arrowSize = 7;
     *   translate(vec.mag() - arrowSize, 0);
     *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
     *   pop();
     * }
     * </code>
     * </div>
     */
    /**
     * @param  {p5.Vector|Number[]} value The vector to add
     * @chainable
     */
    add(...args) {
      if (args[0] instanceof Vector) {
        args = args[0].values;
      } else if (Array.isArray(args[0])) {
        args = args[0];
      }
      args.forEach((value, index) => {
        this.values[index] = (this.values[index] || 0) + (value || 0);
      });
      return this;
    }

    /**
     * Performs modulo (remainder) division with a vector's `x`, `y`, and `z`
     * components.
     *
     * `rem()` can use separate numbers, as in `v.rem(1, 2, 3)`,
     * another <a href="#/p5.Vector">p5.Vector</a> object, as in `v.rem(v2)`, or
     * an array of numbers, as in `v.rem([1, 2, 3])`.
     *
     * If only one value is provided, as in `v.rem(2)`, then all the components
     * will be set to their values modulo 2. If two values are provided, as in
     * `v.rem(2, 3)`, then `v.z` won't change. Calling `rem()` with no
     * arguments, as in `v.rem()`, has no effect.
     *
     * The static version of `rem()`, as in `p5.Vector.rem(v2, v1)`, returns a
     * new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
     * originals.
     *
     * @param {Number} x x component of divisor vector.
     * @param {Number} y y component of divisor vector.
     * @param {Number} z z component of divisor vector.
     * @chainable
     *
     * @example
     * <div class='norender'>
     * <code>
     * function setup() {
     *   // Create a p5.Vector object.
     *   let v = createVector(3, 4, 5);
     *
     *   // Divide numbers.
     *   v.rem(2);
     *
     *   // Prints 'p5.Vector Object : [1, 0, 1]'.
     *   print(v.toString());
     * }
     * </code>
     * </div>
     *
     * <div class='norender'>
     * <code>
     * function setup() {
     *   // Create a p5.Vector object.
     *   let v = createVector(3, 4, 5);
     *
     *   // Divide numbers.
     *   v.rem(2, 3);
     *
     *   // Prints 'p5.Vector Object : [1, 1, 5]'.
     *   print(v.toString());
     * }
     * </code>
     * </div>
     *
     * <div class='norender'>
     * <code>
     * function setup() {
     *   // Create a p5.Vector object.
     *   let v = createVector(3, 4, 5);
     *
     *   // Divide numbers.
     *   v.rem(2, 3, 4);
     *
     *   // Prints 'p5.Vector Object : [1, 1, 1]'.
     *   print(v.toString());
     * }
     * </code>
     * </div>
     *
     * <div class='norender'>
     * <code>
     * function setup() {
     *   // Create p5.Vector objects.
     *   let v1 = createVector(3, 4, 5);
     *   let v2 = createVector(2, 3, 4);
     *
     *   // Divide a p5.Vector.
     *   v1.rem(v2);
     *
     *   // Prints 'p5.Vector Object : [1, 1, 1]'.
     *   print(v1.toString());
     * }
     * </code>
     * </div>
     *
     * <div class='norender'>
     * <code>
     * function setup() {
     *   // Create a p5.Vector object.
     *   let v = createVector(3, 4, 5);
     *
     *   // Divide an array.
     *   let arr = [2, 3, 4];
     *   v.rem(arr);
     *
     *   // Prints 'p5.Vector Object : [1, 1, 1]'.
     *   print(v.toString());
     * }
     * </code>
     * </div>
     *
     * <div class="norender">
     * <code>
     * function setup() {
     *   // Create p5.Vector objects.
     *   let v1 = createVector(3, 4, 5);
     *   let v2 = createVector(2, 3, 4);
     *
     *   // Divide without modifying the original vectors.
     *   let v3 = p5.Vector.rem(v1, v2);
     *
     *   // Prints 'p5.Vector Object : [1, 1, 1]'.
     *   print(v3.toString());
     * }
     * </code>
     * </div>
     */
    /**
     * @param {p5.Vector | Number[]}  value  divisor vector.
     * @chainable
     */
    rem(x, y, z) {
      if (x instanceof Vector) {
        if ([x.x, x.y, x.z].every(Number.isFinite)) {
          const xComponent = parseFloat(x.x);
          const yComponent = pars